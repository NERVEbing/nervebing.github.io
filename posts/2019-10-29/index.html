<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL/innoDB 内部实现 | Lv's Playground</title><meta name=keywords content="MySQL,innoDB"><meta name=description content="MySQL存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持767字节；而在开启innodb_large_prefix属性值的情况下，最大能支持3072字节 前缀索引，后缀索引，手动md5哈希索引 innode内置哈希 Cardinality 不重复值预估 ，除以记录总数的比例 尽量接近1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位(索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引(a,b) 中的b index hint 索引提示 use index 只是提示，force index才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown （IPC）优化，将where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现 ，使用了FTS Index Cache 缓存数据变更，批量更新到Auxiliary Table中(这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005版之前只支持页锁，2005开始支持行锁，但是实现方式与innodb不同，加锁会有资源开销，innodb则与oracle 的锁实现类似"><meta name=author content="L"><link rel=canonical href=https://lvlv.fun/posts/2019-10-29/><link crossorigin=anonymous href=/assets/css/stylesheet.ff5c563355d86912897c94851bec85fecf6816cfe531f24a52abb2be8acde1a4.css integrity="sha256-/1xWM1XYaRKJfJSFG+yF/s9oFs/lMfJKUquyvorN4aQ=" rel="preload stylesheet" as=style><link rel=icon href=https://lvlv.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lvlv.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lvlv.fun/favicon-32x32.png><link rel=apple-touch-icon href=https://lvlv.fun/apple-touch-icon.png><link rel=mask-icon href=https://lvlv.fun/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var _paq=window._paq=window._paq||[];_paq.push(['trackPageView']),_paq.push(['enableLinkTracking']),function(){e="//matomo.lvlv.fun/",_paq.push(['setTrackerUrl',e+'matomo.php']),_paq.push(['setSiteId','1']);var e,n=document,t=n.createElement('script'),s=n.getElementsByTagName('script')[0];t.async=!0,t.src=e+'matomo.js',s.parentNode.insertBefore(t,s)}()</script><meta property="og:title" content="MySQL/innoDB 内部实现"><meta property="og:description" content="MySQL存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持767字节；而在开启innodb_large_prefix属性值的情况下，最大能支持3072字节 前缀索引，后缀索引，手动md5哈希索引 innode内置哈希 Cardinality 不重复值预估 ，除以记录总数的比例 尽量接近1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位(索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引(a,b) 中的b index hint 索引提示 use index 只是提示，force index才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown （IPC）优化，将where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现 ，使用了FTS Index Cache 缓存数据变更，批量更新到Auxiliary Table中(这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005版之前只支持页锁，2005开始支持行锁，但是实现方式与innodb不同，加锁会有资源开销，innodb则与oracle 的锁实现类似"><meta property="og:type" content="article"><meta property="og:url" content="https://lvlv.fun/posts/2019-10-29/"><meta property="og:image" content="https://lvlv.fun/apple-touch-icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-29T19:12:30+08:00"><meta property="article:modified_time" content="2019-10-29T19:12:30+08:00"><meta property="og:site_name" content="Lv's Playground"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lvlv.fun/apple-touch-icon.png"><meta name=twitter:title content="MySQL/innoDB 内部实现"><meta name=twitter:description content="MySQL存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持767字节；而在开启innodb_large_prefix属性值的情况下，最大能支持3072字节 前缀索引，后缀索引，手动md5哈希索引 innode内置哈希 Cardinality 不重复值预估 ，除以记录总数的比例 尽量接近1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位(索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引(a,b) 中的b index hint 索引提示 use index 只是提示，force index才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown （IPC）优化，将where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现 ，使用了FTS Index Cache 缓存数据变更，批量更新到Auxiliary Table中(这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005版之前只支持页锁，2005开始支持行锁，但是实现方式与innodb不同，加锁会有资源开销，innodb则与oracle 的锁实现类似"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://lvlv.fun/posts/"},{"@type":"ListItem","position":3,"name":"MySQL/innoDB 内部实现","item":"https://lvlv.fun/posts/2019-10-29/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL/innoDB 内部实现","name":"MySQL\/innoDB 内部实现","description":"MySQL存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持767字节；而在开启innodb_large_prefix属性值的情况下，最大能支持3072字节 前缀索引，后缀索引，手动md5哈希索引 innode内置哈希 Cardinality 不重复值预估 ，除以记录总数的比例 尽量接近1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位(索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引(a,b) 中的b index hint 索引提示 use index 只是提示，force index才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown （IPC）优化，将where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现 ，使用了FTS Index Cache 缓存数据变更，批量更新到Auxiliary Table中(这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005版之前只支持页锁，2005开始支持行锁，但是实现方式与innodb不同，加锁会有资源开销，innodb则与oracle 的锁实现类似","keywords":["MySQL","innoDB"],"articleBody":"MySQL存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持767字节；而在开启innodb_large_prefix属性值的情况下，最大能支持3072字节 前缀索引，后缀索引，手动md5哈希索引 innode内置哈希 Cardinality 不重复值预估 ，除以记录总数的比例 尽量接近1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位(索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引(a,b) 中的b index hint 索引提示 use index 只是提示，force index才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown （IPC）优化，将where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现 ，使用了FTS Index Cache 缓存数据变更，批量更新到Auxiliary Table中(这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005版之前只支持页锁，2005开始支持行锁，但是实现方式与innodb不同，加锁会有资源开销，innodb则与oracle 的锁实现类似\nlock 锁，与latch锁， lock用于事务，latch用于保证并发下的数据一致性（临界资源）\n查看latch锁 show engine innodb mutex;\n查看lock 锁 show engine innodb status;\n共享锁 s Lock，允许事务读一行数据，共享锁可以叠加，称为锁兼容\n排他锁 x Lock,允许事务删除或者更新一行数据\n意向锁 (Intention Lock) ,对子级上锁，需要怼父级上意向锁，s锁，对应is,x锁对应ix\n查看锁的情况，show full processlist,show engine innodb status, information_schema下的，innodb_trx,innodb_locks,innodb_lock_waits 等三张表\n如果没有合适的索引，则innodb会使用主键来进行锁定(可能会造成表锁)\n索引含有唯一属性时，where id=1 类似的查询Next-Key Lock 会降级为Record Lock\n锁的问题 脏读 (read uncommited级别下)脏数据是事务对缓冲池中的行记录的修改，并且没有被提交(commit),脏读就是读到了未提交数据\n不可重复读 (read commited级别下) 在当前事务两次读取不一致，第二次读到了其他事务提交的数据\n丢失更新 一个事务的更新，被另外一个事务覆盖，数据库本身不会发生这个错误，程序缓存变量值再写入时可能发生\n阻塞 innodb 默认不会回滚阻塞超时引发的异常\n死锁 基础是等待一方超时，innodb还采用 wait-for graph(等待图) 深度优先算法 采用递归实现(innodb 1.2之后采用非递归方式实现递归)\n发生死锁的因素 1.并发事务数量 2.每个事务操作的数量 3.操作数据的集合大小，集合越大越不容易冲突\ninnodb一般情况出错，不会回滚事务，但是死锁除外，死锁时，innodb会回滚其中一个事务，死锁报错(1213)\n事务 ACID 原子性(atomicity) 一致性(consistency) 隔离性(isolation) 持久性(durability)\n事务的分类 扁平事务(Flat Transactions) 带有保存点的扁平事务(Flat Transactions with Savepoints) 链事务(Chained Transactions) 嵌套事务(Nested Transactions) 分布式事务(Distributed Transactions)\n事务的隔离性由锁来实现\n事务的原子性，一致性，持久性 通过 redo log和undo log来完成\nInnodb不支持嵌套事务，当执行一个START TRANSACTION指令时，会隐式的执行一个commit操作。\n事务控制 innodb默认是自动提交的(auto commit)\nbegin/start transaction 显示的开启事务\n隐式提交的sql语句:alter 等修改表结构，修改数据库的语句\n事务操作的统计 com_commit与com_rollback (默认是自动提交autocommit=1,不会记入这两字段) show global status like ‘com_commit’\n另外两个参数 handler_commit与handle_rollback\n事务隔离级别\n隔离级别Isolation Level 脏读Dirty Read 不可重复读NonRepeatable Read 幻读Phantom Read 未提交读Read uncommitted 可能 可能 可能 已提交读Read committed 不可能 可能 可能 可重复读Repeatable read 不可能 不可能 可能 可串行化Serializable 不可能 不可能 不可能 未提交读(Read Uncommitted)：\n允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。\n已提交读(Read Committed)：\n只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别（不重复读）。\n可重复读(Repeated Read)：\n可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。\n可串行化(Serializable)：\n完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞，innodb在repeatable read隔离级别下就能达到3度的隔离，所以一般不需要serializable。\n幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。\n分布式事务 innodb 支持XA事务，通过XA事务来支持分布式事务的实现\nXA事务支持不同数据库之间的分布式事务\nXA事务由一个或多个资源管理器(Resource Managers),一个事务管理器(Transaction Manager)以及一个应用程序(Application Program)组成\n资源管理器:提供访问事务资源的方法，通常就是数据库\n事务管理器:协调参与全局事务中的各个事务 (MySQL服务器的客户端)\n应用程序:定义事务的边界，指定全局事务中的操作\nJava的JTA(Java Transaction API)可以很好的支持MySQL的分布式事务\nMySQL内部也存在另外一种内部XA事务，在存储引擎与插件直接，或者不同存储引擎之间\n最常见的内部XA事务是binlog与innodb存储引擎之间\n不好的事务习惯，在循环中提交事务 使用自动提交，使用自动回滚\n日志 redo log 重做日志 用来保证事务的原子性和持久性， redo log 有单独的文件保存\nredo log 记录物理修改，某个表空间，某个页，某条记录的值\nredo log 分为两部分 内存中的 redo log buffer 重做日志文件 redo log file\n事务提交时，必须将重做日志持久化，才算完成，即每次提交commit,写入重做日志到磁盘后都会调用fsync，强制写入到磁盘，避免停留在文件系统的写入缓冲\n通过修改配置可以改变重做日志刷新模式， innodb_flush_log_at_trx_commit 默认为1，改为0不写入重做日志，而是等待一个时间周期(1s)后由master thread统一操作，设置为2表示提交时仅写入文件系统缓存\ninnodb_flush_log_at_trx_commit 改为0或2时，对事务性能有明显的提升，但是在特定的条件下会牺牲数据的一致性，即写入到缓存而未刷新到硬盘\nredo log 以512字节进行存储，以块(block)的方式进行保存， 称为重做块日志 redo log block\nblock 大小与磁盘扇区大小一致，保证写入的原子性，不需要doublewrite技术\ninnodb1.2之前，重做日志总大小要小于4G,innodb1.2开始限制提高到512G\n重做日志，格式 redo_log_type:重做日志类型 space:表空间id page_no:也的偏移量\nLSN(Log Sequence Number)日志序列号 含义:1.重做日志写入的字节总量 2.checkpoint的位置 3:页的版本\nshow engine innodb status 可以查看lsn的情况\nLog sequence number 当前的LSN Log flushed up to 表示刷新到重做日志文件的LSN Pages flushed up to Last checkpoint at 刷新到磁盘的LSN\n生成环境这几个的值可能不同\nundo log 用来保证事务的一致性，undo log 默认存放在共享表空间中的undo 段中(undo segment)，innodb1.2开始可以修改配置，存放在单独的文件中\nundo log 记录逻辑修改，回滚时反向操作\nmvcc就是通过undo log来实现\ninnodb1.1之前 只有一个rollback segment,每个回滚段记录了1024个undo log segment,所以innodb1.1之前只支持并发1024个事务\ninnodb1.1开始支持最大128个rollback segment 所以支持同时在线事务的数量为128*1024\n事务提交后不能马上删除undo log，因为可能还有其他事务需要读取事务提交前的行记录版本，由单独的pure线程来判断是否需要最终删除undolog\nundo 页可以重用\nHistory list length 代表undo log的数量，purge 会减少这个数量\ninnodb还不能直接查看undo信息。 innosql对information_schema进行扩展，添加了两张数据字典表来查看undo信息 innodb_trx_rollback_segment,查看rollbacksetment,innodb_trx_undo 记录undo log\nrelay log relay log很多方面都跟binary log差不多，区别是：从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后SQL线程会读取relay-log日志的内容并应用到从服务器。\ngroup commit 一次fsync确保多个事务日志被写入文件\ninnodb1.2之前开启二进制日志后，group commit会失效，因为开启二进制日志后，为了保证存储引擎层的事务与二进制日志的一致性，必须每个步骤都使用fsync，使用prepare_commit_mutex保证顺序 ** 1) 当事务提交时，Innodb存储引擎进行prepare操作 ** 2) MySQL数据库上层写入二进制日志 (fsync由sync_binlog控制) ** 3) Innodb粗糙你引擎层将日志写入重做日志问的 a)修改内存中事务对应的信息，并且将日志写入重做日志缓冲 b)调用fsync将确保日志都从重做日志缓冲写入磁盘 (fsync由 innodb_flush_log_at_trx_commit参数控制)\nMySQL5.6实现了BLGC(Binary Log Group Commit) 使得数据库层与innodb存储引擎层都实现了group cimmit ,移除了 prepare_commit_mutex锁，提高了性能\n二进制日志(binlog) ,用来进行POINT-IN-TIME(PIT)的恢复，以及主从复制(Replication)环境的建立\n重做日志由innodb产生，二进制日志则是在MySQL数据库层产生,对任何存储引擎都会产生二进制日志\n二进制日志是逻辑日志，记录的是对应的sql语句，而重做日志是物理格式日志\n二进制日志是事务提交后一次写入，而重做日志是事务每次操作都写入\n重做日志是幂等的，二进制日志不是\nbinlog 分为 statement与row两种类型\n备份与恢复 备份方式 mysqldump,ibbackup,replication,第三方工具:xtrabackup,LVM快照备份\n热备(Hot Backup) 数据库运行中直接无影响备份 冷备(Cold Backup) 数据库停机时备份，(复制物理文件) 温备 (Warm Backup) 数据库运行中有影响备份，(e.g加全局读锁)\n逻辑备份，裸文件备份\n完全备份， 增量备份，MySQL本身没有增量备份，通过二进制日志来完成增量备份(效率很低)，可以使用xtrabackup工具 日志备份 二进制日志文件\n性能调优 选择64位CPU,64位MySQL\n内存，在达到MySQL数据本身大小前，内存与性能，线性增加\n机械硬盘与固态硬盘，不同特性对性能的影响， 机械硬盘，随机读性能差，固态硬盘随机读性能好，但是覆盖更新性能有局限，根据不同硬件情况来调整参数与程序设计\n合理的设置RAID， 有的RAID卡支持写入缓存，可以很好的提高性能，同时注意需要内置UPS电源才能避免数据丢失\n部分文件系统支持文件快照\n不同操作系统对MySQL有不同的影响\n选择合适的基准测试工具sysbench ,mysql-tpcc\n","wordCount":"442","inLanguage":"en","datePublished":"2019-10-29T19:12:30+08:00","dateModified":"2019-10-29T19:12:30+08:00","author":{"@type":"Person","name":"L"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lvlv.fun/posts/2019-10-29/"},"publisher":{"@type":"Organization","name":"Lv's Playground","logo":{"@type":"ImageObject","url":"https://lvlv.fun/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://lvlv.fun accesskey=h title="Started (Alt + H)"><img src=https://lvlv.fun/apple-touch-icon.png alt aria-label=logo height=35>Started</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://lvlv.fun/navigation/ title=Navigation><span>Navigation</span></a></li><li><a href=https://lvlv.fun/live/ title=Live><span>Live</span></a></li><li><a href=https://lvlv.fun/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://lvlv.fun/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lvlv.fun>Home</a>&nbsp;»&nbsp;<a href=https://lvlv.fun/posts/>Posts</a></div><h1 class=post-title>MySQL/innoDB 内部实现</h1><div class=post-meta><span title='2019-10-29 19:12:30 +0800 +0800'>2019-10-29</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;L&nbsp;|&nbsp;<a href=https://github.com/NERVEbing/blog/blob/master/content/posts/2019-10-29.md rel="noopener noreferrer" target=_blank>edit</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#mysql%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84 aria-label=MySQL存储结构>MySQL存储结构</a></li><li><a href=#%e7%b4%a2%e5%bc%95 aria-label=索引>索引</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e7%bb%86%e8%8a%82 aria-label=索引细节>索引细节</a></li></ul></li><li><a href=#%e9%94%81 aria-label=锁>锁</a><ul><li><a href=#%e9%94%81%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=锁的问题>锁的问题</a></li></ul></li><li><a href=#%e4%ba%8b%e5%8a%a1 aria-label=事务>事务</a><ul><li><a href=#%e4%ba%8b%e5%8a%a1%e6%8e%a7%e5%88%b6 aria-label=事务控制>事务控制</a></li><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1 aria-label=分布式事务>分布式事务</a></li></ul></li><li><a href=#%e6%97%a5%e5%bf%97 aria-label=日志>日志</a></li><li><a href=#%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d aria-label=备份与恢复>备份与恢复</a></li><li><a href=#%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98 aria-label=性能调优>性能调优</a></li></ul></div></details></div><div class=post-content><h2 id=mysql存储结构>MySQL存储结构<a hidden class=anchor aria-hidden=true href=#mysql存储结构>#</a></h2><ol><li>B-tree 是平衡的多路查找树。</li><li>涉及到磁盘的查找需要设法减少磁盘 I/O 次数。</li><li>B-tree 就是为解决这个问题而引入的数据结构。</li></ol><ul><li>区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」)</li><li>我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O</li><li>在最坏情况下，B-tree 的一次检索最多需要H（树的高度）次的磁盘 I/O</li><li>实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引</li></ul><h2 id=索引>索引<a hidden class=anchor aria-hidden=true href=#索引>#</a></h2><ul><li>字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持767字节；而在开启innodb_large_prefix属性值的情况下，最大能支持3072字节</li><li>前缀索引，后缀索引，手动md5哈希索引</li><li>innode内置哈希</li><li>Cardinality 不重复值预估 ，除以记录总数的比例 尽量接近1 索引的价值越大</li><li>查询优化器 选择索引时会考虑这个值</li><li>oltp olap</li><li>Online Analytical Processing</li><li>Online transaction processing</li></ul><h3 id=索引细节>索引细节<a hidden class=anchor aria-hidden=true href=#索引细节>#</a></h3><ul><li>单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引</li><li>覆盖索引</li><li>数据最小读取单位(索引页？)</li><li>count(*) 操作，实际会读取辅助索引，避免读取聚合索引</li><li>统计操作，覆盖索引的情况下，可以直接查询复合索引(a,b) 中的b</li><li>index hint 索引提示 use index 只是提示，force index才是强制</li><li>multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行</li><li>index condition pushdown （IPC）优化，将where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition)</li><li>innodb 全文索引 使用倒排索引实现 ，使用了FTS Index Cache 缓存数据变更，批量更新到Auxiliary Table中(这个表可以通过关键词定位到文档，单词位置)</li></ul><h2 id=锁>锁<a hidden class=anchor aria-hidden=true href=#锁>#</a></h2><ul><li><p>myisam 只支持表锁，sql server 2005版之前只支持页锁，2005开始支持行锁，但是实现方式与innodb不同，加锁会有资源开销，innodb则与oracle 的锁实现类似</p></li><li><p>lock 锁，与latch锁， lock用于事务，latch用于保证并发下的数据一致性（临界资源）</p></li><li><p>查看latch锁 show engine innodb mutex;</p></li><li><p>查看lock 锁 show engine innodb status;</p></li><li><p>共享锁 s Lock，允许事务读一行数据，共享锁可以叠加，称为锁兼容</p></li><li><p>排他锁 x Lock,允许事务删除或者更新一行数据</p></li><li><p>意向锁 (Intention Lock) ,对子级上锁，需要怼父级上意向锁，s锁，对应is,x锁对应ix</p></li><li><p>查看锁的情况，show full processlist,show engine innodb status, information_schema下的，innodb_trx,innodb_locks,innodb_lock_waits 等三张表</p></li><li><p>如果没有合适的索引，则innodb会使用主键来进行锁定(可能会造成表锁)</p></li><li><p>索引含有唯一属性时，where id=1 类似的查询Next-Key Lock 会降级为Record Lock</p></li></ul><h3 id=锁的问题>锁的问题<a hidden class=anchor aria-hidden=true href=#锁的问题>#</a></h3><ul><li><p>脏读 (read uncommited级别下)脏数据是事务对缓冲池中的行记录的修改，并且没有被提交(commit),脏读就是读到了未提交数据</p></li><li><p>不可重复读 (read commited级别下) 在当前事务两次读取不一致，第二次读到了其他事务提交的数据</p></li><li><p>丢失更新 一个事务的更新，被另外一个事务覆盖，数据库本身不会发生这个错误，程序缓存变量值再写入时可能发生</p></li><li><p>阻塞 innodb 默认不会回滚阻塞超时引发的异常</p></li><li><p>死锁 基础是等待一方超时，innodb还采用 wait-for graph(等待图) 深度优先算法 采用递归实现(innodb 1.2之后采用非递归方式实现递归)</p></li><li><p>发生死锁的因素 1.并发事务数量 2.每个事务操作的数量 3.操作数据的集合大小，集合越大越不容易冲突</p></li><li><p>innodb一般情况出错，不会回滚事务，但是死锁除外，死锁时，innodb会回滚其中一个事务，死锁报错(1213)</p></li></ul><h2 id=事务>事务<a hidden class=anchor aria-hidden=true href=#事务>#</a></h2><ul><li><p>ACID 原子性(atomicity) 一致性(consistency) 隔离性(isolation) 持久性(durability)</p></li><li><p>事务的分类 扁平事务(Flat Transactions) 带有保存点的扁平事务(Flat Transactions with Savepoints) 链事务(Chained Transactions) 嵌套事务(Nested Transactions) 分布式事务(Distributed Transactions)</p></li><li><p>事务的隔离性由锁来实现</p></li><li><p>事务的原子性，一致性，持久性 通过 redo log和undo log来完成</p></li><li><p>Innodb不支持嵌套事务，当执行一个START TRANSACTION指令时，会隐式的执行一个commit操作。</p></li></ul><h3 id=事务控制>事务控制<a hidden class=anchor aria-hidden=true href=#事务控制>#</a></h3><ul><li><p>innodb默认是自动提交的(auto commit)</p></li><li><p>begin/start transaction 显示的开启事务</p></li><li><p>隐式提交的sql语句:alter 等修改表结构，修改数据库的语句</p></li><li><p>事务操作的统计 com_commit与com_rollback (默认是自动提交autocommit=1,不会记入这两字段) show global status like ‘com_commit’</p></li><li><p>另外两个参数 handler_commit与handle_rollback</p></li><li><p>事务隔离级别</p></li></ul><table><thead><tr><th style=text-align:left>隔离级别Isolation Level</th><th style=text-align:center>脏读Dirty Read</th><th style=text-align:center>不可重复读NonRepeatable Read</th><th style=text-align:center>幻读Phantom Read</th></tr></thead><tbody><tr><td style=text-align:left>未提交读Read uncommitted</td><td style=text-align:center>可能</td><td style=text-align:center>可能</td><td style=text-align:center>可能</td></tr><tr><td style=text-align:left>已提交读Read committed</td><td style=text-align:center>不可能</td><td style=text-align:center>可能</td><td style=text-align:center>可能</td></tr><tr><td style=text-align:left>可重复读Repeatable read</td><td style=text-align:center>不可能</td><td style=text-align:center>不可能</td><td style=text-align:center>可能</td></tr><tr><td style=text-align:left>可串行化Serializable</td><td style=text-align:center>不可能</td><td style=text-align:center>不可能</td><td style=text-align:center>不可能</td></tr></tbody></table><blockquote><p>未提交读(Read Uncommitted)：</p><p>允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</p></blockquote><blockquote><p>已提交读(Read Committed)：</p><p>只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别（不重复读）。</p></blockquote><blockquote><p>可重复读(Repeated Read)：</p><p>可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</p></blockquote><blockquote><p>可串行化(Serializable)：</p><p>完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞，innodb在repeatable read隔离级别下就能达到3度的隔离，所以一般不需要serializable。</p></blockquote><blockquote><p><em>幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</em></p></blockquote><h3 id=分布式事务>分布式事务<a hidden class=anchor aria-hidden=true href=#分布式事务>#</a></h3><ul><li><p>innodb 支持XA事务，通过XA事务来支持分布式事务的实现</p></li><li><p>XA事务支持不同数据库之间的分布式事务</p></li><li><p>XA事务由一个或多个资源管理器(Resource Managers),一个事务管理器(Transaction Manager)以及一个应用程序(Application Program)组成</p></li><li><p>资源管理器:提供访问事务资源的方法，通常就是数据库</p></li><li><p>事务管理器:协调参与全局事务中的各个事务 (MySQL服务器的客户端)</p></li><li><p>应用程序:定义事务的边界，指定全局事务中的操作</p></li><li><p>Java的JTA(Java Transaction API)可以很好的支持MySQL的分布式事务</p></li><li><p>MySQL内部也存在另外一种内部XA事务，在存储引擎与插件直接，或者不同存储引擎之间</p></li><li><p>最常见的内部XA事务是binlog与innodb存储引擎之间</p></li><li><p>不好的事务习惯，在循环中提交事务 使用自动提交，使用自动回滚</p></li></ul><h2 id=日志>日志<a hidden class=anchor aria-hidden=true href=#日志>#</a></h2><ul><li><p>redo log 重做日志 用来保证事务的原子性和持久性， redo log 有单独的文件保存</p></li><li><p>redo log 记录物理修改，某个表空间，某个页，某条记录的值</p></li><li><p>redo log 分为两部分 内存中的 redo log buffer 重做日志文件 redo log file</p></li><li><p>事务提交时，必须将重做日志持久化，才算完成，即每次提交commit,写入重做日志到磁盘后都会调用fsync，强制写入到磁盘，避免停留在文件系统的写入缓冲</p></li><li><p>通过修改配置可以改变重做日志刷新模式， innodb_flush_log_at_trx_commit 默认为1，改为0不写入重做日志，而是等待一个时间周期(1s)后由master thread统一操作，设置为2表示提交时仅写入文件系统缓存</p></li><li><p>innodb_flush_log_at_trx_commit 改为0或2时，对事务性能有明显的提升，但是在特定的条件下会牺牲数据的一致性，即写入到缓存而未刷新到硬盘</p></li><li><p>redo log 以512字节进行存储，以块(block)的方式进行保存， 称为重做块日志 redo log block</p></li><li><p>block 大小与磁盘扇区大小一致，保证写入的原子性，不需要doublewrite技术</p></li><li><p>innodb1.2之前，重做日志总大小要小于4G,innodb1.2开始限制提高到512G</p></li><li><p>重做日志，格式 redo_log_type:重做日志类型 space:表空间id page_no:也的偏移量</p></li><li><p>LSN(Log Sequence Number)日志序列号 含义:1.重做日志写入的字节总量 2.checkpoint的位置 3:页的版本</p></li><li><p>show engine innodb status 可以查看lsn的情况</p></li><li><p>Log sequence number 当前的LSN
Log flushed up to 表示刷新到重做日志文件的LSN Pages flushed up to Last checkpoint at 刷新到磁盘的LSN</p></li><li><p>生成环境这几个的值可能不同</p></li><li><p>undo log 用来保证事务的一致性，undo log 默认存放在共享表空间中的undo 段中(undo segment)，innodb1.2开始可以修改配置，存放在单独的文件中</p></li><li><p>undo log 记录逻辑修改，回滚时反向操作</p></li><li><p>mvcc就是通过undo log来实现</p></li><li><p>innodb1.1之前 只有一个rollback segment,每个回滚段记录了1024个undo log segment,所以innodb1.1之前只支持并发1024个事务</p></li><li><p>innodb1.1开始支持最大128个rollback segment 所以支持同时在线事务的数量为128*1024</p></li><li><p>事务提交后不能马上删除undo log，因为可能还有其他事务需要读取事务提交前的行记录版本，由单独的pure线程来判断是否需要最终删除undolog</p></li><li><p>undo 页可以重用</p></li><li><p>History list length 代表undo log的数量，purge 会减少这个数量</p></li><li><p>innodb还不能直接查看undo信息。 innosql对information_schema进行扩展，添加了两张数据字典表来查看undo信息 innodb_trx_rollback_segment,查看rollbacksetment,innodb_trx_undo 记录undo log</p></li><li><p>relay log relay log很多方面都跟binary log差不多，区别是：从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后SQL线程会读取relay-log日志的内容并应用到从服务器。</p></li><li><p>group commit 一次fsync确保多个事务日志被写入文件</p></li><li><p>innodb1.2之前开启二进制日志后，group commit会失效，因为开启二进制日志后，为了保证存储引擎层的事务与二进制日志的一致性，必须每个步骤都使用fsync，使用prepare_commit_mutex保证顺序 ** 1) 当事务提交时，Innodb存储引擎进行prepare操作 ** 2) MySQL数据库上层写入二进制日志 (fsync由sync_binlog控制) ** 3) Innodb粗糙你引擎层将日志写入重做日志问的 a)修改内存中事务对应的信息，并且将日志写入重做日志缓冲 b)调用fsync将确保日志都从重做日志缓冲写入磁盘 (fsync由 innodb_flush_log_at_trx_commit参数控制)</p></li><li><p>MySQL5.6实现了BLGC(Binary Log Group Commit) 使得数据库层与innodb存储引擎层都实现了group cimmit ,移除了 prepare_commit_mutex锁，提高了性能</p></li><li><p>二进制日志(binlog) ,用来进行POINT-IN-TIME(PIT)的恢复，以及主从复制(Replication)环境的建立</p></li><li><p>重做日志由innodb产生，二进制日志则是在MySQL数据库层产生,对任何存储引擎都会产生二进制日志</p></li><li><p>二进制日志是逻辑日志，记录的是对应的sql语句，而重做日志是物理格式日志</p></li><li><p>二进制日志是事务提交后一次写入，而重做日志是事务每次操作都写入</p></li><li><p>重做日志是幂等的，二进制日志不是</p></li><li><p>binlog 分为 statement与row两种类型</p></li></ul><h2 id=备份与恢复>备份与恢复<a hidden class=anchor aria-hidden=true href=#备份与恢复>#</a></h2><ul><li><p>备份方式 mysqldump,ibbackup,replication,第三方工具:xtrabackup,LVM快照备份</p></li><li><p>热备(Hot Backup) 数据库运行中直接无影响备份 冷备(Cold Backup) 数据库停机时备份，(复制物理文件) 温备 (Warm Backup) 数据库运行中有影响备份，(e.g加全局读锁)</p></li><li><p>逻辑备份，裸文件备份</p></li><li><p>完全备份， 增量备份，MySQL本身没有增量备份，通过二进制日志来完成增量备份(效率很低)，可以使用xtrabackup工具 日志备份 二进制日志文件</p></li></ul><h2 id=性能调优>性能调优<a hidden class=anchor aria-hidden=true href=#性能调优>#</a></h2><ul><li><p>选择64位CPU,64位MySQL</p></li><li><p>内存，在达到MySQL数据本身大小前，内存与性能，线性增加</p></li><li><p>机械硬盘与固态硬盘，不同特性对性能的影响， 机械硬盘，随机读性能差，固态硬盘随机读性能好，但是覆盖更新性能有局限，根据不同硬件情况来调整参数与程序设计</p></li><li><p>合理的设置RAID， 有的RAID卡支持写入缓存，可以很好的提高性能，同时注意需要内置UPS电源才能避免数据丢失</p></li><li><p>部分文件系统支持文件快照</p></li><li><p>不同操作系统对MySQL有不同的影响</p></li><li><p>选择合适的基准测试工具sysbench ,mysql-tpcc</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://lvlv.fun/tags/mysql/>MySQL</a></li><li><a href=https://lvlv.fun/tags/innodb/>innoDB</a></li></ul><nav class=paginav><a class=prev href=https://lvlv.fun/posts/2022-05-08/><span class=title>« Prev</span><br><span>基于 HPE MicroServer Gen10 Plus 的 HomeLab 搭建 - 硬件篇</span></a>
<a class=next href=https://lvlv.fun/posts/2019-07-22/><span class=title>Next »</span><br><span>gRPC Connection reset by peer 问题</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var t=document,e=t.createElement('script');e.async=!0,e.src='//lvs-playground.disqus.com/embed.js',e.setAttribute('data-timestamp',+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://lvlv.fun>Lv's Playground</a></span>
<span>|</span>
<span><a href=https://beian.miit.gov.cn/>皖ICP备2022006072号-1</a></span>
<span>|</span>
<span><img style=display:inline;margin-bottom:-.8em src="https://matomo.lvlv.fun/index.php?module=FlagCounter&action=image&idSite=1&period=range&date=last365&sort=popular&activated=&rows=1&cols=1&showcode=1&showflag=0&fontsize=8&fontcolor=218,218,219&font=Roboto-Regular" alt=flag></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll('pre > code').forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement('button');e.classList.add('copy-code'),e.innerText='copy';function s(){e.innerText='copied!',setTimeout(()=>{e.innerText='copy'},2e3)}e.addEventListener('click',o=>{if('clipboard'in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand('copy'),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>