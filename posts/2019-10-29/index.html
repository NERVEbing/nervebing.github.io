<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL/innoDB 内部实现 | Lv's Playground</title>
<meta name=keywords content="MySQL,innoDB"><meta name=description content="MySQL 存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要 H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree 的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持 767 字节；而在开启 innodb_large_prefix 属性值的情况下，最大能支持 3072 字节 前缀索引，后缀索引，手动 md5 哈希索引 innode 内置哈希 Cardinality 不重复值预估，除以记录总数的比例 尽量接近 1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位 (索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引 (a,b) 中的 b index hint 索引提示 use index 只是提示，force index 才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown（IPC）优化，将 where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现，使用了 FTS Index Cache 缓存数据变更，批量更新到 Auxiliary Table 中 ( 这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005 版之前只支持页锁，2005 开始支持行锁，但是实现方式与 innodb 不同，加锁会有资源开销，innodb 则与 oracle 的锁实现类似"><meta name=author content="L"><link rel=canonical href=https://lvlv.fun/posts/2019-10-29/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://lvlv.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lvlv.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lvlv.fun/favicon-32x32.png><link rel=apple-touch-icon href=https://lvlv.fun/apple-touch-icon.png><link rel=mask-icon href=https://lvlv.fun/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://lvlv.fun/posts/2019-10-29/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7.0/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/mononoki@5.0.7/index.min.css><script defer src=https://hi.lvlv.fun/hi.js data-website-id=685c7d96-4af8-4152-8071-ff743ac81947 data-domains=lvlv.fun></script><script>const isLightMode=function(){return localStorage.getItem("pref-theme")!=="dark"},getModeSwitch=function(){return document.getElementById("theme-toggle")}</script><meta property="og:title" content="MySQL/innoDB 内部实现"><meta property="og:description" content="MySQL 存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要 H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree 的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持 767 字节；而在开启 innodb_large_prefix 属性值的情况下，最大能支持 3072 字节 前缀索引，后缀索引，手动 md5 哈希索引 innode 内置哈希 Cardinality 不重复值预估，除以记录总数的比例 尽量接近 1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位 (索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引 (a,b) 中的 b index hint 索引提示 use index 只是提示，force index 才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown（IPC）优化，将 where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现，使用了 FTS Index Cache 缓存数据变更，批量更新到 Auxiliary Table 中 ( 这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005 版之前只支持页锁，2005 开始支持行锁，但是实现方式与 innodb 不同，加锁会有资源开销，innodb 则与 oracle 的锁实现类似"><meta property="og:type" content="article"><meta property="og:url" content="https://lvlv.fun/posts/2019-10-29/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-29T19:12:30+08:00"><meta property="article:modified_time" content="2019-10-29T19:12:30+08:00"><meta property="og:site_name" content="Lv's Playground"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL/innoDB 内部实现"><meta name=twitter:description content="MySQL 存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要 H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree 的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持 767 字节；而在开启 innodb_large_prefix 属性值的情况下，最大能支持 3072 字节 前缀索引，后缀索引，手动 md5 哈希索引 innode 内置哈希 Cardinality 不重复值预估，除以记录总数的比例 尽量接近 1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位 (索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引 (a,b) 中的 b index hint 索引提示 use index 只是提示，force index 才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown（IPC）优化，将 where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现，使用了 FTS Index Cache 缓存数据变更，批量更新到 Auxiliary Table 中 ( 这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005 版之前只支持页锁，2005 开始支持行锁，但是实现方式与 innodb 不同，加锁会有资源开销，innodb 则与 oracle 的锁实现类似"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lvlv.fun/posts/"},{"@type":"ListItem","position":2,"name":"MySQL/innoDB 内部实现","item":"https://lvlv.fun/posts/2019-10-29/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL/innoDB 内部实现","name":"MySQL\/innoDB 内部实现","description":"MySQL 存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要 H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree 的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持 767 字节；而在开启 innodb_large_prefix 属性值的情况下，最大能支持 3072 字节 前缀索引，后缀索引，手动 md5 哈希索引 innode 内置哈希 Cardinality 不重复值预估，除以记录总数的比例 尽量接近 1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位 (索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引 (a,b) 中的 b index hint 索引提示 use index 只是提示，force index 才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown（IPC）优化，将 where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现，使用了 FTS Index Cache 缓存数据变更，批量更新到 Auxiliary Table 中 ( 这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005 版之前只支持页锁，2005 开始支持行锁，但是实现方式与 innodb 不同，加锁会有资源开销，innodb 则与 oracle 的锁实现类似","keywords":["MySQL","innoDB"],"articleBody":"MySQL 存储结构 B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。 区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要 H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree 的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引 索引 字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持 767 字节；而在开启 innodb_large_prefix 属性值的情况下，最大能支持 3072 字节 前缀索引，后缀索引，手动 md5 哈希索引 innode 内置哈希 Cardinality 不重复值预估，除以记录总数的比例 尽量接近 1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing 索引细节 单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位 (索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引 (a,b) 中的 b index hint 索引提示 use index 只是提示，force index 才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown（IPC）优化，将 where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现，使用了 FTS Index Cache 缓存数据变更，批量更新到 Auxiliary Table 中 ( 这个表可以通过关键词定位到文档，单词位置) 锁 myisam 只支持表锁，sql server 2005 版之前只支持页锁，2005 开始支持行锁，但是实现方式与 innodb 不同，加锁会有资源开销，innodb 则与 oracle 的锁实现类似\nlock 锁，与 latch 锁，lock 用于事务，latch 用于保证并发下的数据一致性（临界资源）\n查看 latch 锁 show engine innodb mutex;\n查看 lock 锁 show engine innodb status;\n共享锁 s Lock，允许事务读一行数据，共享锁可以叠加，称为锁兼容\n排他锁 x Lock，允许事务删除或者更新一行数据\n意向锁 (Intention Lock) ,对子级上锁，需要怼父级上意向锁，s 锁，对应 is,x 锁对应 ix\n查看锁的情况，show full processlist,show engine innodb status, information_schema 下的，innodb_trx,innodb_locks,innodb_lock_waits 等三张表\n如果没有合适的索引，则 innodb 会使用主键来进行锁定 (可能会造成表锁)\n索引含有唯一属性时，where id=1 类似的查询 Next-Key Lock 会降级为 Record Lock\n锁的问题 脏读 (read uncommited 级别下) 脏数据是事务对缓冲池中的行记录的修改，并且没有被提交 (commit),脏读就是读到了未提交数据\n不可重复读 (read commited 级别下) 在当前事务两次读取不一致，第二次读到了其他事务提交的数据\n丢失更新 一个事务的更新，被另外一个事务覆盖，数据库本身不会发生这个错误，程序缓存变量值再写入时可能发生\n阻塞 innodb 默认不会回滚阻塞超时引发的异常\n死锁 基础是等待一方超时，innodb 还采用 wait-for graph(等待图) 深度优先算法 采用递归实现 (innodb 1.2 之后采用非递归方式实现递归)\n发生死锁的因素 1.并发事务数量 2.每个事务操作的数量 3.操作数据的集合大小，集合越大越不容易冲突\ninnodb 一般情况出错，不会回滚事务，但是死锁除外，死锁时，innodb 会回滚其中一个事务，死锁报错 (1213)\n事务 ACID 原子性 (atomicity) 一致性 (consistency) 隔离性 (isolation) 持久性 (durability)\n事务的分类 扁平事务 (Flat Transactions) 带有保存点的扁平事务 (Flat Transactions with Savepoints) 链事务 (Chained Transactions) 嵌套事务 (Nested Transactions) 分布式事务 (Distributed Transactions)\n事务的隔离性由锁来实现\n事务的原子性，一致性，持久性 通过 redo log 和 undo log 来完成\nInnodb 不支持嵌套事务，当执行一个 START TRANSACTION 指令时，会隐式的执行一个 commit 操作。\n事务控制 innodb 默认是自动提交的 (auto commit)\nbegin/start transaction 显示的开启事务\n隐式提交的 sql 语句:alter 等修改表结构，修改数据库的语句\n事务操作的统计 com_commit 与 com_rollback (默认是自动提交 autocommit=1，不会记入这两字段) show global status like‘com_commit’\n另外两个参数 handler_commit 与 handle_rollback\n事务隔离级别\n隔离级别Isolation Level 脏读Dirty Read 不可重复读NonRepeatable Read 幻读Phantom Read 未提交读Read uncommitted 可能 可能 可能 已提交读Read committed 不可能 可能 可能 可重复读Repeatable read 不可能 不可能 可能 可串行化Serializable 不可能 不可能 不可能 未提交读 (Read Uncommitted)：\n允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。\n已提交读 (Read Committed)：\n只能读取到已经提交的数据。Oracle 等多数数据库默认都是该级别（不重复读）。\n可重复读 (Repeated Read)：\n可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB 默认级别。在 SQL 标准中，该隔离级别消除了不可重复读，但是还存在幻象读。\n可串行化 (Serializable)：\n完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞，innodb 在 repeatable read 隔离级别下就能达到 3 度的隔离，所以一般不需要 serializable。\n幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。\n分布式事务 innodb 支持 XA 事务，通过 XA 事务来支持分布式事务的实现\nXA 事务支持不同数据库之间的分布式事务\nXA 事务由一个或多个资源管理器 (Resource Managers),一个事务管理器 (Transaction Manager) 以及一个应用程序 (Application Program) 组成\n资源管理器：提供访问事务资源的方法，通常就是数据库\n事务管理器：协调参与全局事务中的各个事务 (MySQL 服务器的客户端)\n应用程序：定义事务的边界，指定全局事务中的操作\nJava 的 JTA(Java Transaction API) 可以很好的支持 MySQL 的分布式事务\nMySQL 内部也存在另外一种内部 XA 事务，在存储引擎与插件直接，或者不同存储引擎之间\n最常见的内部 XA 事务是 binlog 与 innodb 存储引擎之间\n不好的事务习惯，在循环中提交事务 使用自动提交，使用自动回滚\n日志 redo log 重做日志 用来保证事务的原子性和持久性，redo log 有单独的文件保存\nredo log 记录物理修改，某个表空间，某个页，某条记录的值\nredo log 分为两部分 内存中的 redo log buffer 重做日志文件 redo log file\n事务提交时，必须将重做日志持久化，才算完成，即每次提交 commit，写入重做日志到磁盘后都会调用 fsync，强制写入到磁盘，避免停留在文件系统的写入缓冲\n通过修改配置可以改变重做日志刷新模式，innodb_flush_log_at_trx_commit 默认为 1，改为 0 不写入重做日志，而是等待一个时间周期 (1s) 后由 master thread 统一操作，设置为 2 表示提交时仅写入文件系统缓存\ninnodb_flush_log_at_trx_commit 改为 0 或 2 时，对事务性能有明显的提升，但是在特定的条件下会牺牲数据的一致性，即写入到缓存而未刷新到硬盘\nredo log 以 512 字节进行存储，以块 (block) 的方式进行保存，称为重做块日志 redo log block\nblock 大小与磁盘扇区大小一致，保证写入的原子性，不需要 doublewrite 技术\ninnodb1.2 之前，重做日志总大小要小于 4G,innodb1.2 开始限制提高到 512G\n重做日志，格式 redo_log_type:重做日志类型 space:表空间 id page_no:也的偏移量\nLSN(Log Sequence Number) 日志序列号 含义:1.重做日志写入的字节总量 2.checkpoint 的位置 3:页的版本\nshow engine innodb status 可以查看 lsn 的情况\nLog sequence number 当前的 LSN Log flushed up to 表示刷新到重做日志文件的 LSN Pages flushed up to Last checkpoint at 刷新到磁盘的 LSN\n生成环境这几个的值可能不同\nundo log 用来保证事务的一致性，undo log 默认存放在共享表空间中的 undo 段中 (undo segment)，innodb1.2 开始可以修改配置，存放在单独的文件中\nundo log 记录逻辑修改，回滚时反向操作\nmvcc 就是通过 undo log 来实现\ninnodb1.1 之前 只有一个 rollback segment，每个回滚段记录了 1024 个 undo log segment，所以 innodb1.1 之前只支持并发 1024 个事务\ninnodb1.1 开始支持最大 128 个 rollback segment 所以支持同时在线事务的数量为 128*1024\n事务提交后不能马上删除 undo log，因为可能还有其他事务需要读取事务提交前的行记录版本，由单独的 pure 线程来判断是否需要最终删除 undolog\nundo 页可以重用\nHistory list length 代表 undo log 的数量，purge 会减少这个数量\ninnodb 还不能直接查看 undo 信息。innosql 对 information_schema 进行扩展，添加了两张数据字典表来查看 undo 信息 innodb_trx_rollback_segment，查看 rollbacksetment,innodb_trx_undo 记录 undo log\nrelay log relay log 很多方面都跟 binary log 差不多，区别是：从服务器 I/O 线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后 SQL 线程会读取 relay-log 日志的内容并应用到从服务器。\ngroup commit 一次 fsync 确保多个事务日志被写入文件\ninnodb1.2 之前开启二进制日志后，group commit 会失效，因为开启二进制日志后，为了保证存储引擎层的事务与二进制日志的一致性，必须每个步骤都使用 fsync，使用 prepare_commit_mutex 保证顺序 ** 1) 当事务提交时，Innodb 存储引擎进行 prepare 操作 ** 2) MySQL 数据库上层写入二进制日志 (fsync 由 sync_binlog 控制) ** 3) Innodb 粗糙你引擎层将日志写入重做日志问的 a) 修改内存中事务对应的信息，并且将日志写入重做日志缓冲 b) 调用 fsync 将确保日志都从重做日志缓冲写入磁盘 (fsync 由 innodb_flush_log_at_trx_commit 参数控制)\nMySQL5.6 实现了 BLGC(Binary Log Group Commit) 使得数据库层与 innodb 存储引擎层都实现了 group cimmit ,移除了 prepare_commit_mutex 锁，提高了性能\n二进制日志 (binlog) ,用来进行 POINT-IN-TIME(PIT) 的恢复，以及主从复制 (Replication) 环境的建立\n重做日志由 innodb 产生，二进制日志则是在 MySQL 数据库层产生，对任何存储引擎都会产生二进制日志\n二进制日志是逻辑日志，记录的是对应的 sql 语句，而重做日志是物理格式日志\n二进制日志是事务提交后一次写入，而重做日志是事务每次操作都写入\n重做日志是幂等的，二进制日志不是\nbinlog 分为 statement 与 row 两种类型\n备份与恢复 备份方式 mysqldump,ibbackup,replication,第三方工具:xtrabackup,LVM快照备份\n热备 (Hot Backup) 数据库运行中直接无影响备份 冷备 (Cold Backup) 数据库停机时备份，(复制物理文件) 温备 (Warm Backup) 数据库运行中有影响备份，(e.g 加全局读锁)\n逻辑备份，裸文件备份\n完全备份，增量备份，MySQL 本身没有增量备份，通过二进制日志来完成增量备份 (效率很低)，可以使用 xtrabackup 工具 日志备份 二进制日志文件\n性能调优 选择 64 位 CPU,64 位 MySQL\n内存，在达到 MySQL 数据本身大小前，内存与性能，线性增加\n机械硬盘与固态硬盘，不同特性对性能的影响，机械硬盘，随机读性能差，固态硬盘随机读性能好，但是覆盖更新性能有局限，根据不同硬件情况来调整参数与程序设计\n合理的设置 RAID，有的 RAID 卡支持写入缓存，可以很好的提高性能，同时注意需要内置 UPS 电源才能避免数据丢失\n部分文件系统支持文件快照\n不同操作系统对 MySQL 有不同的影响\n选择合适的基准测试工具 sysbench ,mysql-tpcc\n","wordCount":"693","inLanguage":"en","datePublished":"2019-10-29T19:12:30+08:00","dateModified":"2019-10-29T19:12:30+08:00","author":{"@type":"Person","name":"L"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lvlv.fun/posts/2019-10-29/"},"publisher":{"@type":"Organization","name":"Lv's Playground","logo":{"@type":"ImageObject","url":"https://lvlv.fun/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://lvlv.fun/ accesskey=h title="Started (Alt + H)"><img src=https://lvlv.fun/apple-touch-icon.png alt aria-label=logo height=35>Started</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://lvlv.fun/latest/ title=Latest><span>Latest</span></a></li><li><a href=https://lvlv.fun/navigation/ title=Navigation><span>Navigation</span></a></li><li><a href=https://lvlv.fun/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lvlv.fun/>Home</a>&nbsp;»&nbsp;<a href=https://lvlv.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">MySQL/innoDB 内部实现</h1><div class=post-meta><span title='2019-10-29 19:12:30 +0800 +0800'>2019-10-29</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;L&nbsp;|&nbsp;<a href=https://github.com/NERVEbing/blog/blob/master/content/posts/2019-10-29.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#mysql-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84 aria-label="MySQL 存储结构">MySQL 存储结构</a></li><li><a href=#%e7%b4%a2%e5%bc%95 aria-label=索引>索引</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e7%bb%86%e8%8a%82 aria-label=索引细节>索引细节</a></li></ul></li><li><a href=#%e9%94%81 aria-label=锁>锁</a><ul><li><a href=#%e9%94%81%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=锁的问题>锁的问题</a></li></ul></li><li><a href=#%e4%ba%8b%e5%8a%a1 aria-label=事务>事务</a><ul><li><a href=#%e4%ba%8b%e5%8a%a1%e6%8e%a7%e5%88%b6 aria-label=事务控制>事务控制</a></li><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1 aria-label=分布式事务>分布式事务</a></li></ul></li><li><a href=#%e6%97%a5%e5%bf%97 aria-label=日志>日志</a></li><li><a href=#%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d aria-label=备份与恢复>备份与恢复</a></li><li><a href=#%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98 aria-label=性能调优>性能调优</a></li></ul></div></details></div><div class=post-content><h2 id=mysql-存储结构>MySQL 存储结构<a hidden class=anchor aria-hidden=true href=#mysql-存储结构>#</a></h2><ol><li>B-tree 是平衡的多路查找树。</li><li>涉及到磁盘的查找需要设法减少磁盘 I/O 次数。</li><li>B-tree 就是为解决这个问题而引入的数据结构。</li></ol><ul><li>区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」)</li><li>我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘
I/O</li><li>在最坏情况下，B-tree 的一次检索最多需要 H（树的高度）次的磁盘 I/O</li><li>实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree 的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎
InnoDB 就采用 B+-tree 来实现聚簇索引</li></ul><h2 id=索引>索引<a hidden class=anchor aria-hidden=true href=#索引>#</a></h2><ul><li>字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持 767 字节；而在开启 innodb_large_prefix 属性值的情况下，最大能支持
3072 字节</li><li>前缀索引，后缀索引，手动 md5 哈希索引</li><li>innode 内置哈希</li><li>Cardinality 不重复值预估，除以记录总数的比例 尽量接近 1 索引的价值越大</li><li>查询优化器 选择索引时会考虑这个值</li><li>oltp olap</li><li>Online Analytical Processing</li><li>Online transaction processing</li></ul><h3 id=索引细节>索引细节<a hidden class=anchor aria-hidden=true href=#索引细节>#</a></h3><ul><li>单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引</li><li>覆盖索引</li><li>数据最小读取单位 (索引页？)</li><li>count(*) 操作，实际会读取辅助索引，避免读取聚合索引</li><li>统计操作，覆盖索引的情况下，可以直接查询复合索引 (a,b) 中的 b</li><li>index hint 索引提示 use index 只是提示，force index 才是强制</li><li>multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行</li><li>index condition pushdown（IPC）优化，将 where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition)</li><li>innodb 全文索引 使用倒排索引实现，使用了 FTS Index Cache 缓存数据变更，批量更新到 Auxiliary Table 中 (
这个表可以通过关键词定位到文档，单词位置)</li></ul><h2 id=锁>锁<a hidden class=anchor aria-hidden=true href=#锁>#</a></h2><ul><li><p>myisam 只支持表锁，sql server 2005 版之前只支持页锁，2005 开始支持行锁，但是实现方式与 innodb 不同，加锁会有资源开销，innodb
则与 oracle 的锁实现类似</p></li><li><p>lock 锁，与 latch 锁，lock 用于事务，latch 用于保证并发下的数据一致性（临界资源）</p></li><li><p>查看 latch 锁 show engine innodb mutex;</p></li><li><p>查看 lock 锁 show engine innodb status;</p></li><li><p>共享锁 s Lock，允许事务读一行数据，共享锁可以叠加，称为锁兼容</p></li><li><p>排他锁 x Lock，允许事务删除或者更新一行数据</p></li><li><p>意向锁 (Intention Lock) ,对子级上锁，需要怼父级上意向锁，s 锁，对应 is,x 锁对应 ix</p></li><li><p>查看锁的情况，show full processlist,show engine innodb status, information_schema
下的，innodb_trx,innodb_locks,innodb_lock_waits 等三张表</p></li><li><p>如果没有合适的索引，则 innodb 会使用主键来进行锁定 (可能会造成表锁)</p></li><li><p>索引含有唯一属性时，where id=1 类似的查询 Next-Key Lock 会降级为 Record Lock</p></li></ul><h3 id=锁的问题>锁的问题<a hidden class=anchor aria-hidden=true href=#锁的问题>#</a></h3><ul><li><p>脏读 (read uncommited 级别下) 脏数据是事务对缓冲池中的行记录的修改，并且没有被提交 (commit),脏读就是读到了未提交数据</p></li><li><p>不可重复读 (read commited 级别下) 在当前事务两次读取不一致，第二次读到了其他事务提交的数据</p></li><li><p>丢失更新 一个事务的更新，被另外一个事务覆盖，数据库本身不会发生这个错误，程序缓存变量值再写入时可能发生</p></li><li><p>阻塞 innodb 默认不会回滚阻塞超时引发的异常</p></li><li><p>死锁 基础是等待一方超时，innodb 还采用 wait-for graph(等待图) 深度优先算法 采用递归实现 (innodb 1.2
之后采用非递归方式实现递归)</p></li><li><p>发生死锁的因素 1.并发事务数量 2.每个事务操作的数量 3.操作数据的集合大小，集合越大越不容易冲突</p></li><li><p>innodb 一般情况出错，不会回滚事务，但是死锁除外，死锁时，innodb 会回滚其中一个事务，死锁报错 (1213)</p></li></ul><h2 id=事务>事务<a hidden class=anchor aria-hidden=true href=#事务>#</a></h2><ul><li><p>ACID 原子性 (atomicity) 一致性 (consistency) 隔离性 (isolation) 持久性 (durability)</p></li><li><p>事务的分类 扁平事务 (Flat Transactions) 带有保存点的扁平事务 (Flat Transactions with Savepoints) 链事务 (Chained
Transactions) 嵌套事务 (Nested Transactions) 分布式事务 (Distributed Transactions)</p></li><li><p>事务的隔离性由锁来实现</p></li><li><p>事务的原子性，一致性，持久性 通过 redo log 和 undo log 来完成</p></li><li><p>Innodb 不支持嵌套事务，当执行一个 START TRANSACTION 指令时，会隐式的执行一个 commit 操作。</p></li></ul><h3 id=事务控制>事务控制<a hidden class=anchor aria-hidden=true href=#事务控制>#</a></h3><ul><li><p>innodb 默认是自动提交的 (auto commit)</p></li><li><p>begin/start transaction 显示的开启事务</p></li><li><p>隐式提交的 sql 语句:alter 等修改表结构，修改数据库的语句</p></li><li><p>事务操作的统计 com_commit 与 com_rollback (默认是自动提交 autocommit=1，不会记入这两字段) show global status
like‘com_commit’</p></li><li><p>另外两个参数 handler_commit 与 handle_rollback</p></li><li><p>事务隔离级别</p></li></ul><table><thead><tr><th style=text-align:left>隔离级别Isolation Level</th><th style=text-align:center>脏读Dirty Read</th><th style=text-align:center>不可重复读NonRepeatable Read</th><th style=text-align:center>幻读Phantom Read</th></tr></thead><tbody><tr><td style=text-align:left>未提交读Read uncommitted</td><td style=text-align:center>可能</td><td style=text-align:center>可能</td><td style=text-align:center>可能</td></tr><tr><td style=text-align:left>已提交读Read committed</td><td style=text-align:center>不可能</td><td style=text-align:center>可能</td><td style=text-align:center>可能</td></tr><tr><td style=text-align:left>可重复读Repeatable read</td><td style=text-align:center>不可能</td><td style=text-align:center>不可能</td><td style=text-align:center>可能</td></tr><tr><td style=text-align:left>可串行化Serializable</td><td style=text-align:center>不可能</td><td style=text-align:center>不可能</td><td style=text-align:center>不可能</td></tr></tbody></table><blockquote><p>未提交读 (Read Uncommitted)：</p><p>允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</p></blockquote><blockquote><p>已提交读 (Read Committed)：</p><p>只能读取到已经提交的数据。Oracle 等多数数据库默认都是该级别（不重复读）。</p></blockquote><blockquote><p>可重复读 (Repeated Read)：</p><p>可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB 默认级别。在 SQL 标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</p></blockquote><blockquote><p>可串行化 (Serializable)：</p><p>完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞，innodb 在 repeatable read 隔离级别下就能达到 3 度的隔离，所以一般不需要
serializable。</p></blockquote><blockquote><p><em>幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select
某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</em></p></blockquote><h3 id=分布式事务>分布式事务<a hidden class=anchor aria-hidden=true href=#分布式事务>#</a></h3><ul><li><p>innodb 支持 XA 事务，通过 XA 事务来支持分布式事务的实现</p></li><li><p>XA 事务支持不同数据库之间的分布式事务</p></li><li><p>XA 事务由一个或多个资源管理器 (Resource Managers),一个事务管理器 (Transaction Manager) 以及一个应用程序 (Application
Program) 组成</p></li><li><p>资源管理器：提供访问事务资源的方法，通常就是数据库</p></li><li><p>事务管理器：协调参与全局事务中的各个事务 (MySQL 服务器的客户端)</p></li><li><p>应用程序：定义事务的边界，指定全局事务中的操作</p></li><li><p>Java 的 JTA(Java Transaction API) 可以很好的支持 MySQL 的分布式事务</p></li><li><p>MySQL 内部也存在另外一种内部 XA 事务，在存储引擎与插件直接，或者不同存储引擎之间</p></li><li><p>最常见的内部 XA 事务是 binlog 与 innodb 存储引擎之间</p></li><li><p>不好的事务习惯，在循环中提交事务 使用自动提交，使用自动回滚</p></li></ul><h2 id=日志>日志<a hidden class=anchor aria-hidden=true href=#日志>#</a></h2><ul><li><p>redo log 重做日志 用来保证事务的原子性和持久性，redo log 有单独的文件保存</p></li><li><p>redo log 记录物理修改，某个表空间，某个页，某条记录的值</p></li><li><p>redo log 分为两部分 内存中的 redo log buffer 重做日志文件 redo log file</p></li><li><p>事务提交时，必须将重做日志持久化，才算完成，即每次提交 commit，写入重做日志到磁盘后都会调用 fsync，强制写入到磁盘，避免停留在文件系统的写入缓冲</p></li><li><p>通过修改配置可以改变重做日志刷新模式，innodb_flush_log_at_trx_commit 默认为 1，改为 0
不写入重做日志，而是等待一个时间周期 (1s) 后由 master thread 统一操作，设置为 2 表示提交时仅写入文件系统缓存</p></li><li><p>innodb_flush_log_at_trx_commit 改为 0 或 2 时，对事务性能有明显的提升，但是在特定的条件下会牺牲数据的一致性，即写入到缓存而未刷新到硬盘</p></li><li><p>redo log 以 512 字节进行存储，以块 (block) 的方式进行保存，称为重做块日志 redo log block</p></li><li><p>block 大小与磁盘扇区大小一致，保证写入的原子性，不需要 doublewrite 技术</p></li><li><p>innodb1.2 之前，重做日志总大小要小于 4G,innodb1.2 开始限制提高到 512G</p></li><li><p>重做日志，格式 redo_log_type:重做日志类型 space:表空间 id page_no:也的偏移量</p></li><li><p>LSN(Log Sequence Number) 日志序列号 含义:1.重做日志写入的字节总量 2.checkpoint 的位置 3:页的版本</p></li><li><p>show engine innodb status 可以查看 lsn 的情况</p></li><li><p>Log sequence number 当前的 LSN
Log flushed up to 表示刷新到重做日志文件的 LSN Pages flushed up to Last checkpoint at 刷新到磁盘的 LSN</p></li><li><p>生成环境这几个的值可能不同</p></li><li><p>undo log 用来保证事务的一致性，undo log 默认存放在共享表空间中的 undo 段中 (undo segment)，innodb1.2 开始可以修改配置，存放在单独的文件中</p></li><li><p>undo log 记录逻辑修改，回滚时反向操作</p></li><li><p>mvcc 就是通过 undo log 来实现</p></li><li><p>innodb1.1 之前 只有一个 rollback segment，每个回滚段记录了 1024 个 undo log segment，所以 innodb1.1 之前只支持并发 1024
个事务</p></li><li><p>innodb1.1 开始支持最大 128 个 rollback segment 所以支持同时在线事务的数量为 128*1024</p></li><li><p>事务提交后不能马上删除 undo log，因为可能还有其他事务需要读取事务提交前的行记录版本，由单独的 pure 线程来判断是否需要最终删除
undolog</p></li><li><p>undo 页可以重用</p></li><li><p>History list length 代表 undo log 的数量，purge 会减少这个数量</p></li><li><p>innodb 还不能直接查看 undo 信息。innosql 对 information_schema 进行扩展，添加了两张数据字典表来查看 undo 信息
innodb_trx_rollback_segment，查看 rollbacksetment,innodb_trx_undo 记录 undo log</p></li><li><p>relay log relay log 很多方面都跟 binary log 差不多，区别是：从服务器 I/O 线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后
SQL 线程会读取 relay-log 日志的内容并应用到从服务器。</p></li><li><p>group commit 一次 fsync 确保多个事务日志被写入文件</p></li><li><p>innodb1.2 之前开启二进制日志后，group commit 会失效，因为开启二进制日志后，为了保证存储引擎层的事务与二进制日志的一致性，必须每个步骤都使用
fsync，使用 prepare_commit_mutex 保证顺序 ** 1) 当事务提交时，Innodb 存储引擎进行 prepare 操作 ** 2) MySQL
数据库上层写入二进制日志 (fsync 由 sync_binlog 控制) ** 3) Innodb 粗糙你引擎层将日志写入重做日志问的 a)
修改内存中事务对应的信息，并且将日志写入重做日志缓冲 b) 调用 fsync 将确保日志都从重做日志缓冲写入磁盘 (fsync 由
innodb_flush_log_at_trx_commit 参数控制)</p></li><li><p>MySQL5.6 实现了 BLGC(Binary Log Group Commit) 使得数据库层与 innodb 存储引擎层都实现了 group cimmit ,移除了
prepare_commit_mutex 锁，提高了性能</p></li><li><p>二进制日志 (binlog) ,用来进行 POINT-IN-TIME(PIT) 的恢复，以及主从复制 (Replication) 环境的建立</p></li><li><p>重做日志由 innodb 产生，二进制日志则是在 MySQL 数据库层产生，对任何存储引擎都会产生二进制日志</p></li><li><p>二进制日志是逻辑日志，记录的是对应的 sql 语句，而重做日志是物理格式日志</p></li><li><p>二进制日志是事务提交后一次写入，而重做日志是事务每次操作都写入</p></li><li><p>重做日志是幂等的，二进制日志不是</p></li><li><p>binlog 分为 statement 与 row 两种类型</p></li></ul><h2 id=备份与恢复>备份与恢复<a hidden class=anchor aria-hidden=true href=#备份与恢复>#</a></h2><ul><li><p>备份方式 mysqldump,ibbackup,replication,第三方工具:xtrabackup,LVM快照备份</p></li><li><p>热备 (Hot Backup) 数据库运行中直接无影响备份 冷备 (Cold Backup) 数据库停机时备份，(复制物理文件) 温备 (Warm Backup)
数据库运行中有影响备份，(e.g 加全局读锁)</p></li><li><p>逻辑备份，裸文件备份</p></li><li><p>完全备份，增量备份，MySQL 本身没有增量备份，通过二进制日志来完成增量备份 (效率很低)，可以使用 xtrabackup 工具 日志备份
二进制日志文件</p></li></ul><h2 id=性能调优>性能调优<a hidden class=anchor aria-hidden=true href=#性能调优>#</a></h2><ul><li><p>选择 64 位 CPU,64 位 MySQL</p></li><li><p>内存，在达到 MySQL 数据本身大小前，内存与性能，线性增加</p></li><li><p>机械硬盘与固态硬盘，不同特性对性能的影响，机械硬盘，随机读性能差，固态硬盘随机读性能好，但是覆盖更新性能有局限，根据不同硬件情况来调整参数与程序设计</p></li><li><p>合理的设置 RAID，有的 RAID 卡支持写入缓存，可以很好的提高性能，同时注意需要内置 UPS 电源才能避免数据丢失</p></li><li><p>部分文件系统支持文件快照</p></li><li><p>不同操作系统对 MySQL 有不同的影响</p></li><li><p>选择合适的基准测试工具 sysbench ,mysql-tpcc</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://lvlv.fun/tags/mysql/>MySQL</a></li><li><a href=https://lvlv.fun/tags/innodb/>InnoDB</a></li></ul><nav class=paginav><a class=prev href=https://lvlv.fun/posts/2022-05-08/><span class=title>« Prev</span><br><span>基于 HPE MicroServer Gen10 Plus 的 HomeLab 搭建 - 硬件篇</span>
</a><a class=next href=https://lvlv.fun/posts/2019-07-22/><span class=title>Next »</span><br><span>gRPC Connection reset by peer 问题</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://lvlv.fun/>Lv's Playground</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>