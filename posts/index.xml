<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Lv&#39;s Playground</title>
    <link>https://lvlv.fun/posts/</link>
    <description>Recent content in Posts on Lv&#39;s Playground</description>
    <image>
      <url>https://lvlv.fun/apple-touch-icon.png</url>
      <link>https://lvlv.fun/apple-touch-icon.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 08 May 2022 11:09:36 +0800</lastBuildDate><atom:link href="https://lvlv.fun/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于HPE MicroServer Gen10 Plus的HomeLab搭建 - 硬件篇</title>
      <link>https://lvlv.fun/posts/2022-05-08/</link>
      <pubDate>Sun, 08 May 2022 11:09:36 +0800</pubDate>
      
      <guid>https://lvlv.fun/posts/2022-05-08/</guid>
      <description>前言 声明 本文是个人对HomeLab即家庭私有实验室的学习探索，参杂着一些经验总结，记录下来，也希望可以让他人少走一些弯路。
HomeLab是什么？ 本质上是一个连接各种设备的复杂系统，你可以用任何树莓派/PC/服务器/路由器组成一个HomeLab。
HomeLab能做什么？  搭建属于私人的网盘，不必在各个设备上安装云盘app才能上传/下载文件 不受版权控制的家庭多媒体，集成影视订阅，实现观影追剧自由 集成HomeBridge以实现在iOS/macOS的Home.app中操作非HomeKit认证的设备 BT下载器，无需开启个人电脑，后台下载资源 RSS订阅器，抛弃无意义地刷手机，只获取自己想要的内容 bilibili每日任务/JD京豆获取，各种脚本反薅资本家的羊毛 最重要的是你可以搭建包括但不限于K8S/ELK/MySQL/Redis/Prometheus等各种服务，也可以在上面跑CI/CD自动化构建发布你的代码  阅读门槛  基本的网络知识，比如光猫和路由器的区别，交换机是干什么的 基本的Linux操作，可以理解计算机不是一定要连接显示器才可以操作 遇到问题先使用英文进行Google，内容过长可以开启页面翻译，请不要看CSDN的内容 不求甚解，当你发现你让它跑起来了的时候，会获得极大的心理满足感  设备 架构说明 主要分为服务器和网络设备。考虑到网络设备的稳定性及网络隔离对整套系统的重要程度，没有采用虚拟化AIO(ALL IN ONE)方案。
作为服务端开发者看来所谓的AIO毫无稳定性可言，ESXi的OpenWrt虚拟机出了故障会影响其他业务虚拟机的运行，甚至连iLO后台都进不去，需要连接显示器手动配置ESXi进行修复，这种情况在异地操作HomeLab节点的时候是毁灭性的灾难。
当然这种方式的好处也有：网上教程多，按视频操作一步步做几乎没有难点，小白也能轻松搭建。
缺点就是对整体的HomeLab环境一知半解甚至根本不懂，只会复制粘贴。当然你可以说“我只是想快速搭建一整套服务，不想了解细节”，这样的话本文可能不适合你。
服务器 首先是最重要的服务器部分，绝大多数设备购入时间为2021年2-3月，价格相比当前可能有很大差距，费用清单如下：
   设备 价格(元) 数量 备注     HPE Gen10 Plus G5420/8GB 4000 1 淘宝/德国转运   iLO5 NIC Kit 399 1 同上   Intel 志强 E-2146G 1400 1 淘宝/QS版   海力士 32GB DDR4 2666MHz ECC 2600 2 淘宝   希捷 Exos X18 16TB 4200 2 淘宝/国行   英睿达 MX500 SATA SSD 2TB 2400 2 京东自营   三星 PM991 256GB + 佳翼硬盘盒 300 1 PM991闲鱼/硬盘盒京东   三星 850PRO SATA SSD 256G 0 2 家用闲置   Intel 傲腾 NVMe SSD 16GB 0 2 家用闲置   Intel 奔腾 G5420 -488 1 闲鱼出了   HPE 原装海力士 8GB ECC -300 1 闲鱼出了   盈通 GTX1650 4GB DDR6 85 1 1535购入/1450出了   佳翼 NVMe 4X4 阵列卡 1200 1 淘宝   总计 15796      之前没怎么认真统计花费，看到总计后还是惊了一下，老实说这个价格可以上塔式服务器或者洋垃圾DIY。选择Gen10 Plus的理由无外乎精致/美观/静音，毕竟这是一台可以放在卧室的服务器。</description>
    </item>
    
    <item>
      <title>MySQL/innoDB内部实现</title>
      <link>https://lvlv.fun/posts/2019-10-29/</link>
      <pubDate>Tue, 29 Oct 2019 19:12:30 +0800</pubDate>
      
      <guid>https://lvlv.fun/posts/2019-10-29/</guid>
      <description>MySQL存储结构  B-tree 是平衡的多路查找树。 涉及到磁盘的查找需要设法减少磁盘 I/O 次数。 B-tree 就是为解决这个问题而引入的数据结构。   区别于二叉树 b-tree 可以拥有很多个子节点（这个度量被称为「内结点出度」) 我们可以在技术上使 B-tree 的结点大小为磁盘一个页的大小，并且在新建结点时直接申请一个页大小的空间，使得结点的物理存储位置也是在一个页里，这样就能实现存取一个结点只需一次磁盘 I/O 在最坏情况下，B-tree 的一次检索最多需要H（树的高度）次的磁盘 I/O 实际上，为了取得更大的内结点出度，各个数据库一般会采用 B-tree的变种如 B+-tree，B*-tree 来实现索引，比如 MySQL 的存储引擎 InnoDB 就采用 B+-tree 来实现聚簇索引  索引  字符串索引，长度限制 innodb 存储引擎，默认前缀长度最大能支持767字节；而在开启innodb_large_prefix属性值的情况下，最大能支持3072字节 前缀索引，后缀索引，手动md5哈希索引 innode内置哈希 Cardinality 不重复值预估 ，除以记录总数的比例 尽量接近1 索引的价值越大 查询优化器 选择索引时会考虑这个值 oltp olap Online Analytical Processing Online transaction processing  索引细节  单列索引币复合索引在每个数据页存的记录要多，所以查询优化器优先使用单列索引 覆盖索引 数据最小读取单位(索引页？) count(*) 操作，实际会读取辅助索引，避免读取聚合索引 统计操作，覆盖索引的情况下，可以直接查询复合索引(a,b) 中的b index hint 索引提示 use index 只是提示，force index才是强制 multi-range read 优化 从辅助索引筛选完之后，将结果，已主键进行排序，再去读聚合索引下的记录行 index condition pushdown （IPC）优化，将where 过滤条件推送到存储引擎，减少数据传输 (使用时会提示 using index condition) innodb 全文索引 使用倒排索引实现 ，使用了FTS Index Cache 缓存数据变更，批量更新到Auxiliary Table中(这个表可以通过关键词定位到文档，单词位置)  锁   myisam 只支持表锁，sql server 2005版之前只支持页锁，2005开始支持行锁，但是实现方式与innodb不同，加锁会有资源开销，innodb则与oracle 的锁实现类似</description>
    </item>
    
    <item>
      <title>gRPC Connection reset by peer 问题</title>
      <link>https://lvlv.fun/posts/2019-07-22/</link>
      <pubDate>Mon, 22 Jul 2019 12:40:20 +0800</pubDate>
      
      <guid>https://lvlv.fun/posts/2019-07-22/</guid>
      <description>前提 因产品需求，需用PHP（v7.0.12）调用k8s集群中gRPC（golang@1.12.0）服务。
问题 经过dev环境测试，当php-fpm启动后第一次调用或者距离上次调用时间20分钟后左右，再次请求gRPC微服务接口，就会返回 Connection reset by peer 错误，说明gRPC服务端或者客户端主动关闭连接了。继续发起请求到服务端，又恢复正常。
思考 经查阅相关资料，发现问题可能出现在k8s集群的kube-proxy模式上。当前k8s环境(dev)下的kube-proxy为ipvs模式，服务端与客户端之间通信如下：
把上图client看成是apsopen-inside服务pod，Backend pod(1~3)看成gRPC服务，可以看出它们之间的交互路径：
1 ---&amp;gt; gRPC server pod1 2gRPC-client ---&amp;gt; ipvs ---&amp;gt; gRPC server pod3 3 ---&amp;gt; gRPC server pod3 我们知道gRPC是基于HTTP/2协议的，gRPC的client和server在交互时会建立多条连接，为了性能，这些连接都是长连接并且是一直保活的。 这段环境中不管是客户端服务还是gRPC服务都被调度到各个相同配置信息的Kubernetes节点上，这些k8s节点的 keep-alive 是一致的，如果出现连接主动关闭的问题，因为从client到server经历了一层ipvs，所以最大的可能就是ipvs出将连接主动断开，而client端还不知情。 搜索 ipvs timeout 关键字找到了下面相关的链接：
 https://github.com/moby/moby/issues/31208 https://success.docker.com/article/ipvs-connection-timeout-issue https://github.com/kubernetes/kubernetes/issues/32457  其中 https://github.com/moby/moby/issues/31208 中是关于docker swarm在overlay网络下长连接的问题，这个和k8s kube-proxy应该是类似的，按照这个链接中的描述查看 我们这套环境关于tcp keepalive的内核参数：
1#进入igo-util-shorturi容器 2 3sysctl net.ipv4.tcp_keepalive_time net.ipv4.tcp_keepalive_probes net.ipv4.tcp_keepalive_intvl 4net.ipv4.tcp_keepalive_time = 7200 5net.ipv4.tcp_keepalive_probes = 9 6net.ipv4.tcp_keepalive_intvl = 75 上面这段参数的含义: net.ipv4.tcp_keepalive_time 是连接时长，当超过这个时间后，每个 net.ipv4.tcp_keepalive_intvl 的时间间隔会发送keepalive数据包， net.</description>
    </item>
    
    <item>
      <title>gRPC error code</title>
      <link>https://lvlv.fun/posts/2019-06-12/</link>
      <pubDate>Wed, 12 Jun 2019 20:04:20 +0800</pubDate>
      
      <guid>https://lvlv.fun/posts/2019-06-12/</guid>
      <description>RPC.response.status.code HTTP RPC Description     0 - OK 200 OK Not an error; returned on success.   1 - CANCELLED 499 Client Closed Request The operation was cancelled, typically by the caller.   2 - UNKNOWN 500 Internal Server Error Unknown error. For example, this error may be returned when a Status value received from another address space belongs to an error space that is not known in this address space.</description>
    </item>
    
    <item>
      <title>Protobuf总结</title>
      <link>https://lvlv.fun/posts/2019-03-14/</link>
      <pubDate>Thu, 14 Mar 2019 11:18:20 +0800</pubDate>
      
      <guid>https://lvlv.fun/posts/2019-03-14/</guid>
      <description>Protobuf是什么  Protobuf是一种平台无关、语言无关、可扩展且轻便高效的序列化数据结构的协议，可以用于通信协议和数据存储等。  传输协议 - 如json、XML IDL - 接口描述语言 存储格式 - 序列化压缩后存储到数据库   核心竞争力  向前向后兼容性 - 新老版本兼容，无需考虑版本升级 多语言代码生成 - 支持Java、Python、PHP、Go等编程语言 快&amp;amp;小 - 序列化、反序列化速度快，压缩比优秀    关键技术 varints编码  每个字节使用其中7位保存数字，最高位表示后面是否还有内容 低位在前，高位在后 保留了fixed32和fixed64，用于传递大的正数 int32、int64、unit32、uint64、bool，序列化结果相互兼容，可以修改  zigzag编码  传统上，负数最高位为1，小负数会浪费编码长度 (n&amp;lt;&amp;lt;1)^(n&amp;gt;&amp;gt;31) -1将会被编码成1，1将会编码成2，-2将会被编码成3 sint32和sint64使用zigzag编码  message structure编码  Tag-Value编码 Tag=(field_number&amp;lt;&amp;lt;3)|wire_type-&amp;gt;varints wire_type:0表示varints，1表示固定64位，5表示固定32位 wire_type:2表示Tag-Length-Value编码（TLV），Length使用varints string、bytes、message嵌套，都采用TLV编码  wire_type只有0、1、2、5，那么3和4去哪了？—被废除了
repeated编码   第一种方式：重复出现的相同tag
  第二种方式：(packed=true)，TLVVV…编码
仅有数字类型才可以使用第二种方法，protocol buffers 3（pb3）中默认第二种，pb2中需要指定，第一种任何情况下会被支持
非repeated情况出现重复tag，后面的覆盖前面的，因此optional和repeated相互兼容
  Map编码 map&amp;lt;key_type,value_type&amp;gt;map_field=N
序列化结果完全等价于：</description>
    </item>
    
    <item>
      <title>learning-go-from-zero-to-hero-part2</title>
      <link>https://lvlv.fun/posts/2018-12-28/</link>
      <pubDate>Fri, 28 Dec 2018 13:34:06 +0800</pubDate>
      
      <guid>https://lvlv.fun/posts/2018-12-28/</guid>
      <description>作者：Milap Neupane
链接：https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86
 函数  main.go包中定义的func main()是执行程序的入口。可以定义和使用更多函数。让我们看一个简单的例子：
1func add(a int, b int) int { 2 c := a + b 3 return c 4} 5func main() { 6 fmt.Println(add(2, 1)) 7} 8// 3  正如我们在上面的例子中所看到的，使用**func关键字后跟函数名来定义Go函数。函数所需的参数**需要根据其数据类型定义，最后是返回的数据类型。
 函数的返回也可以在函数中预定义：
1func add(a int, b int) (c int) { 2 c = a + b 3 return 4} 5func main() { 6 fmt.Println(add(2, 1)) 7} 8// 3  这里c被定义为返回变量。因此，定义的变量c将自动返回，而无需在结尾的return语句中定义。
 还可以从单个函数返回多个返回值，将返回值与逗号分隔开。
1func add(a int, b int) (int, string) { 2 c := a + b 3 return c, &amp;#34;successfully added&amp;#34; 4} 5func main() { 6 sum, message := add(2, 1) 7 fmt.</description>
    </item>
    
    <item>
      <title>learning-go-from-zero-to-hero-part1</title>
      <link>https://lvlv.fun/posts/2018-12-22/</link>
      <pubDate>Sat, 22 Dec 2018 18:47:53 +0800</pubDate>
      
      <guid>https://lvlv.fun/posts/2018-12-22/</guid>
      <description>作者：Milap Neupane
链接：https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86
 开始  想到刚开始学习Go的时候，也是不清不楚地本着拿来能用就行的心态，没有系统学习，导致学习过程中踩坑无数。今天发现一篇文章写的很好，Go语言的特征讲得很细，翻译给需要的初学Go的同学。
前言  让我们从Go（或者称为Golang）的一个小介绍开始。Go由Google工程师Robert Griesemer，Rob Pike和Ken Thompson设计。它是一种静态类型的编译语言。第一个版本于2012年3月作为开源发布。
  “ Go是一种开源编程语言，可以轻松构建简单，可靠，高效的软件 ”
  在许多语言中，有许多方法可以解决给定的问题。程序员可以花很多时间思考解决问题的最佳方法。
 另一方面，Go相信更少的功能 — 只有一种正确的方法来解决问题。
 这节省了开发人员的时间，并使大型代码库易于维护。
  “ 功能越多，成本越高 ” — Rob Pike
 入门  Go由package组成。名为main的包告诉Go编译器被编译为可执行文件，而不是作为library被引用。它是应用程序的主入口。主包定义为：
1package main  让我们在Go工作区中创建一个简单的hello world示例。
工作区  Go中的工作空间由环境变量定义，称为 GOPATH。
 你的任何代码都将写在工作区内。Go将搜索GOPATH目录中的任何包，或者GOROOT在安装Go时默认设置的目录。注：GOROOT 是安装go的路径。
 设置GOPATH为所需的目录。现在，让我们将其添加到文件夹中~/workspace。
1# 定义GOPATH目录 2export GOPATH=~/workspace 3# 进入工作区目录 4cd ~/workspace  在我们刚刚创建的工作区文件夹中创建main.go文件并写入以下代码。
Hello World! 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5) 6 7func main(){ 8 fmt.</description>
    </item>
    
  </channel>
</rss>
