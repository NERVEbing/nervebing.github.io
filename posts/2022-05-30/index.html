<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用 Rust 构建 gRPC 微服务 | Lv's Playground</title><meta name=keywords content="gRPC,Rust,Microservices"><meta name=description content="前言 当前越来越多的公司基于 Google gRPC 通信框架来构建微服务体系，比较流行的是使用 Go/Java/C++ 这样的主流编程语言来编写服务端，我们今天来尝试使用 Rust 语言来实现一个 gRPC 服务端/客户端。
打开官方文档可以看到目前 Rust 并不在 gRPC 官方支持的语言列表中：
Supported languages
C# C++ Dart Go Java Kotlin Node Objective-C PHP Python Ruby 不过不用担心这个问题。我们知道只要某个语言兼容了基于 C/C++ 编写的 gRPC 的核心库，那么该语言就可以完美支持 gRPC。目前 Rust 可以实现 gRPC 的主流 crate 如下：
tonic grpc-rs grpc-rust 以上三种任选其一都可以，只是 grpc-rs/grpc-rust 当前还处于开发状态，我们在这里使用 tonic 包。
构建程序 首先检查你的 Rust 版本：
$ rustc --version rustc 1.61.0 (fe5b13d68 2022-05-18) tonic 适用于 1.56 及以上，如果低于这个版本，你应该先更新你的 Rust 编译器：
$ rustup update stable 确保你已经提前安装了 protobuf："><meta name=author content="L"><link rel=canonical href=https://lvlv.fun/posts/2022-05-30/><link crossorigin=anonymous href=/assets/css/stylesheet.e349f2d070a9588a9170e29d8924691cae1955197538951cdcbc1b6004e66cf8.css integrity="sha256-40ny0HCpWIqRcOKdiSRpHK4ZVRl1OJUc3LwbYATmbPg=" rel="preload stylesheet" as=style><link rel=icon href=https://lvlv.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lvlv.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lvlv.fun/favicon-32x32.png><link rel=apple-touch-icon href=https://lvlv.fun/apple-touch-icon.png><link rel=mask-icon href=https://lvlv.fun/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>let _paq=window._paq=window._paq||[];_paq.push(['trackPageView']),_paq.push(['enableLinkTracking']),function(){let t="//matomo.lvlv.fun/";_paq.push(['setTrackerUrl',t+'matomo.php']),_paq.push(['setSiteId','1']);let n=document,e=n.createElement('script'),s=n.getElementsByTagName('script')[0];e.async=!0,e.src=t+'matomo.js',s.parentNode.insertBefore(e,s)}()</script><meta property="og:title" content="使用 Rust 构建 gRPC 微服务"><meta property="og:description" content="前言 当前越来越多的公司基于 Google gRPC 通信框架来构建微服务体系，比较流行的是使用 Go/Java/C++ 这样的主流编程语言来编写服务端，我们今天来尝试使用 Rust 语言来实现一个 gRPC 服务端/客户端。
打开官方文档可以看到目前 Rust 并不在 gRPC 官方支持的语言列表中：
Supported languages
C# C++ Dart Go Java Kotlin Node Objective-C PHP Python Ruby 不过不用担心这个问题。我们知道只要某个语言兼容了基于 C/C++ 编写的 gRPC 的核心库，那么该语言就可以完美支持 gRPC。目前 Rust 可以实现 gRPC 的主流 crate 如下：
tonic grpc-rs grpc-rust 以上三种任选其一都可以，只是 grpc-rs/grpc-rust 当前还处于开发状态，我们在这里使用 tonic 包。
构建程序 首先检查你的 Rust 版本：
$ rustc --version rustc 1.61.0 (fe5b13d68 2022-05-18) tonic 适用于 1.56 及以上，如果低于这个版本，你应该先更新你的 Rust 编译器：
$ rustup update stable 确保你已经提前安装了 protobuf："><meta property="og:type" content="article"><meta property="og:url" content="https://lvlv.fun/posts/2022-05-30/"><meta property="og:image" content="https://lvlv.fun/apple-touch-icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-30T02:25:11+08:00"><meta property="article:modified_time" content="2022-05-30T02:25:11+08:00"><meta property="og:site_name" content="Lv's Playground"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lvlv.fun/apple-touch-icon.png"><meta name=twitter:title content="使用 Rust 构建 gRPC 微服务"><meta name=twitter:description content="前言 当前越来越多的公司基于 Google gRPC 通信框架来构建微服务体系，比较流行的是使用 Go/Java/C++ 这样的主流编程语言来编写服务端，我们今天来尝试使用 Rust 语言来实现一个 gRPC 服务端/客户端。
打开官方文档可以看到目前 Rust 并不在 gRPC 官方支持的语言列表中：
Supported languages
C# C++ Dart Go Java Kotlin Node Objective-C PHP Python Ruby 不过不用担心这个问题。我们知道只要某个语言兼容了基于 C/C++ 编写的 gRPC 的核心库，那么该语言就可以完美支持 gRPC。目前 Rust 可以实现 gRPC 的主流 crate 如下：
tonic grpc-rs grpc-rust 以上三种任选其一都可以，只是 grpc-rs/grpc-rust 当前还处于开发状态，我们在这里使用 tonic 包。
构建程序 首先检查你的 Rust 版本：
$ rustc --version rustc 1.61.0 (fe5b13d68 2022-05-18) tonic 适用于 1.56 及以上，如果低于这个版本，你应该先更新你的 Rust 编译器：
$ rustup update stable 确保你已经提前安装了 protobuf："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://lvlv.fun/posts/"},{"@type":"ListItem","position":3,"name":"使用 Rust 构建 gRPC 微服务","item":"https://lvlv.fun/posts/2022-05-30/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 Rust 构建 gRPC 微服务","name":"使用 Rust 构建 gRPC 微服务","description":"前言 当前越来越多的公司基于 Google gRPC 通信框架来构建微服务体系，比较流行的是使用 Go/Java/C++ 这样的主流编程语言来编写服务端，我们今天来尝试使用 Rust 语言来实现一个 gRPC 服务端/客户端。\n打开官方文档可以看到目前 Rust 并不在 gRPC 官方支持的语言列表中：\nSupported languages\nC# C++ Dart Go Java Kotlin Node Objective-C PHP Python Ruby 不过不用担心这个问题。我们知道只要某个语言兼容了基于 C/C++ 编写的 gRPC 的核心库，那么该语言就可以完美支持 gRPC。目前 Rust 可以实现 gRPC 的主流 crate 如下：\ntonic grpc-rs grpc-rust 以上三种任选其一都可以，只是 grpc-rs/grpc-rust 当前还处于开发状态，我们在这里使用 tonic 包。\n构建程序 首先检查你的 Rust 版本：\n$ rustc --version rustc 1.61.0 (fe5b13d68 2022-05-18) tonic 适用于 1.56 及以上，如果低于这个版本，你应该先更新你的 Rust 编译器：\n$ rustup update stable 确保你已经提前安装了 protobuf：","keywords":["gRPC","Rust","Microservices"],"articleBody":"前言 当前越来越多的公司基于 Google gRPC 通信框架来构建微服务体系，比较流行的是使用 Go/Java/C++ 这样的主流编程语言来编写服务端，我们今天来尝试使用 Rust 语言来实现一个 gRPC 服务端/客户端。\n打开官方文档可以看到目前 Rust 并不在 gRPC 官方支持的语言列表中：\nSupported languages\nC# C++ Dart Go Java Kotlin Node Objective-C PHP Python Ruby 不过不用担心这个问题。我们知道只要某个语言兼容了基于 C/C++ 编写的 gRPC 的核心库，那么该语言就可以完美支持 gRPC。目前 Rust 可以实现 gRPC 的主流 crate 如下：\ntonic grpc-rs grpc-rust 以上三种任选其一都可以，只是 grpc-rs/grpc-rust 当前还处于开发状态，我们在这里使用 tonic 包。\n构建程序 首先检查你的 Rust 版本：\n$ rustc --version rustc 1.61.0 (fe5b13d68 2022-05-18) tonic 适用于 1.56 及以上，如果低于这个版本，你应该先更新你的 Rust 编译器：\n$ rustup update stable 确保你已经提前安装了 protobuf：\n$ protoc --version libprotoc 3.19.4 # macOS 可以通过以下命令安装 $ brew install protobuf 使用 cargo 新建一个项目\n$ cargo new grpcrs $ cd grpcrs $ cargo run Compiling grpcrs v0.1.0 (/Users/lvlv/Documents/project/demo/grpcrs) Finished dev [unoptimized + debuginfo] target(s) in 0.55s Running `target/debug/grpcrs` Hello, world! 编辑 cargo.toml 文件：\n[package] name = \"grpcrs\" version = \"0.1.0\" edition = \"2021\" [[bin]] name = \"user-server\" path = \"src/user/server.rs\" [[bin]] name = \"user-client\" path = \"src/user/client.rs\" [dependencies] tonic = \"0.7.2\" tokio = { version = \"1.18.2\", features = [\"macros\", \"rt-multi-thread\"] } prost = \"0.10\" [build-dependencies] tonic-build = \"0.7.2\" 创建下列文件：\n$ mkdir -p proto/user src/user $ touch build.rs proto/user/user.proto src/user/{server.rs,client.rs} 当前目录结构：\n$ tree -L 3 . ├── Cargo.lock ├── Cargo.toml ├── build.rs # Cargo 构建脚本 ├── proto │ └── user │ └── user.proto # proto 文件 └── src └── user ├── client.rs # gRPC 客户端代码 └── server.rs # gRPC 服务端代码 分别将以下内容拷贝到各个文件：\nproto/user/user.proto syntax = \"proto3\"; package user; service User { rpc Hello (HelloRequest) returns (HelloReply) {} } message HelloRequest { string name = 1; } message HelloReply { string message = 1; } src/user/server.rs use tonic::{transport::Server, Request, Response, Status}; use user::user_server::{User, UserServer}; use user::{HelloReply, HelloRequest}; pub mod user { tonic::include_proto!(\"user\"); } #[derive(Default)] pub struct UserService {} #[tonic::async_trait] impl User for UserService { async fn hello(\u0026self, request: Request\u003cHelloRequest\u003e) -\u003e Result\u003cResponse\u003cHelloReply\u003e, Status\u003e { println!(\"New user request from {:?}\", request.remote_addr()); let reply = user::HelloReply { message: format!(\"Hello {}!\", request.into_inner().name), }; Ok(Response::new(reply)) } } #[tokio::main] async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let addr = \"127.0.0.1:50051\".parse().unwrap(); let user_service = UserService::default(); println!(\"UserService listening on {}\", addr); Server::builder() .add_service(UserServer::new(user_service)) .serve(addr) .await?; Ok(()) } src/user/client.rs use user::user_client::UserClient; use user::HelloRequest; pub mod user { tonic::include_proto!(\"user\"); } #[tokio::main] async fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let mut client = UserClient::connect(\"http://127.0.0.1:50051\").await?; let request = tonic::Request::new(HelloRequest { name: \"Rick\".into(), }); let response = client.hello(request).await?; println!(\"RESPONSE={:?}\", response); Ok(()) } build.rs use std::{env, path::PathBuf}; fn main() { let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap()); let user_proto = \"proto/user/user.proto\"; tonic_build::configure() .build_server(true) .build_client(true) .out_dir(\u0026out_dir) .file_descriptor_set_path(\u0026out_dir.join(\"user_descriptor.bin\")) .compile(\u0026[user_proto], \u0026[\"proto\"]) .unwrap_or_else(|err| panic!(\"protobuf compile failed: {}\", err)); } 尝试编译代码：\n$ cargo build Compiling proc-macro2 v1.0.39 Compiling unicode-ident v1.0.0 Compiling syn v1.0.95 Compiling libc v0.2.126 Compiling cfg-if v1.0.0 Compiling log v0.4.17 # ... 省略 Compiling hyper v0.14.19 Compiling axum v0.5.6 Compiling hyper-timeout v0.4.1 Compiling tonic v0.7.2 Finished dev [unoptimized + debuginfo] target(s) in 21.01s 如果编译通过，现在我们可以尝试执行编译好的程序了。\n首先启动 gRPC 服务端程序：\n$ cargo run --bin user-server Finished dev [unoptimized + debuginfo] target(s) in 0.04s Running `target/debug/user-server` UserService listening on 127.0.0.1:50051 重新打开一个 terminal 窗口并执行客户端程序：\n$ cargo run --bin user-client Finished dev [unoptimized + debuginfo] target(s) in 0.05s Running `target/debug/user-client` RESPONSE=Response { metadata: MetadataMap { headers: {\"content-type\": \"application/grpc\", \"date\": \"Sun, 29 May 2022 21:54:18 GMT\", \"grpc-status\": \"0\"} }, message: HelloReply { message: \"Hello Rick!\" }, extensions: Extensions } # \u003c- 客户端请求成功并返回响应 此时我们切回服务端 terminal 窗口查看日志：\n# ... UserService listening on 127.0.0.1:50051 New user request from Some(127.0.0.1:52147) # \u003c- 客户端调用成功 至此，一个简单的基于 Rust 的 gRPC 服务端/客户端就实现了。上述代码很简陋，相信只要是接触过 gRPC 的同学都比较容易就可以理解。\n","wordCount":"542","inLanguage":"en","datePublished":"2022-05-30T02:25:11+08:00","dateModified":"2022-05-30T02:25:11+08:00","author":{"@type":"Person","name":"L"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lvlv.fun/posts/2022-05-30/"},"publisher":{"@type":"Organization","name":"Lv's Playground","logo":{"@type":"ImageObject","url":"https://lvlv.fun/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://lvlv.fun accesskey=h title="Started (Alt + H)"><img src=https://lvlv.fun/apple-touch-icon.png alt aria-label=logo height=35>Started</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://lvlv.fun/navigation/ title=Navigation><span>Navigation</span></a></li><li><a href=https://lvlv.fun/live/ title=Live><span>Live</span></a></li><li><a href=https://lvlv.fun/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lvlv.fun>Home</a>&nbsp;»&nbsp;<a href=https://lvlv.fun/posts/>Posts</a></div><h1 class=post-title>使用 Rust 构建 gRPC 微服务</h1><div class=post-meta><span title='2022-05-30 02:25:11 +0800 +0800'>2022-05-30</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;L&nbsp;|&nbsp;<a href=https://github.com/NERVEbing/blog/blob/master/content/posts/2022-05-30.md rel="noopener noreferrer" target=_blank>edit</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e6%9e%84%e5%bb%ba%e7%a8%8b%e5%ba%8f aria-label=构建程序>构建程序</a></li></ul></div></details></div><div class=post-content><h3 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h3><p>当前越来越多的公司基于 Google <a href=https://grpc.io>gRPC</a> 通信框架来构建微服务体系，比较流行的是使用 Go/Java/C++ 这样的主流编程语言来编写服务端，我们今天来尝试使用 Rust 语言来实现一个 gRPC 服务端/客户端。</p><p>打开<a href=https://grpc.io/docs/languages/>官方文档</a>可以看到目前 Rust 并不在 gRPC 官方支持的语言列表中：</p><blockquote><p>Supported languages</p><ul><li>C#</li><li>C++</li><li>Dart</li><li>Go</li><li>Java</li><li>Kotlin</li><li>Node</li><li>Objective-C</li><li>PHP</li><li>Python</li><li>Ruby</li></ul></blockquote><p>不过不用担心这个问题。我们知道只要某个语言兼容了基于 C/C++ 编写的 gRPC 的<a href=https://github.com/grpc/grpc>核心库</a>，那么该语言就可以完美支持 gRPC。目前 Rust 可以实现 gRPC 的主流 crate 如下：</p><ul><li><a href=https://github.com/hyperium/tonic>tonic</a></li><li><a href=https://github.com/tikv/grpc-rs>grpc-rs</a></li><li><a href=https://github.com/stepancheg/grpc-rust>grpc-rust</a></li></ul><p>以上三种任选其一都可以，只是 grpc-rs/grpc-rust 当前还处于开发状态，我们在这里使用 tonic 包。</p><h3 id=构建程序>构建程序<a hidden class=anchor aria-hidden=true href=#构建程序>#</a></h3><p>首先检查你的 Rust 版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ rustc --version
</span></span><span style=display:flex><span>rustc 1.61.0 <span style=color:#ff79c6>(</span>fe5b13d68 2022-05-18<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><p>tonic 适用于 1.56 及以上，如果低于这个版本，你应该先更新你的 Rust 编译器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ rustup update stable
</span></span></code></pre></div><p>确保你已经提前安装了 protobuf：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ protoc --version
</span></span><span style=display:flex><span>libprotoc 3.19.4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># macOS 可以通过以下命令安装
</span></span><span style=display:flex><span>$ brew install protobuf
</span></span></code></pre></div><p>使用 cargo 新建一个项目</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo new grpcrs
</span></span><span style=display:flex><span>$ <span style=color:#8be9fd;font-style:italic>cd</span> grpcrs
</span></span><span style=display:flex><span>$ cargo run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   Compiling grpcrs v0.1.0 <span style=color:#ff79c6>(</span>/Users/lvlv/Documents/project/demo/grpcrs<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    Finished dev <span style=color:#ff79c6>[</span>unoptimized + debuginfo<span style=color:#ff79c6>]</span> target<span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>)</span> in 0.55s
</span></span><span style=display:flex><span>     Running <span style=color:#f1fa8c>`</span>target/debug/grpcrs<span style=color:#f1fa8c>`</span>
</span></span><span style=display:flex><span>Hello, world!
</span></span></code></pre></div><p>编辑 cargo.toml 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[package]
</span></span><span style=display:flex><span>name = <span style=color:#f1fa8c>&#34;grpcrs&#34;</span>
</span></span><span style=display:flex><span>version = <span style=color:#f1fa8c>&#34;0.1.0&#34;</span>
</span></span><span style=display:flex><span>edition = <span style=color:#f1fa8c>&#34;2021&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[[bin]]
</span></span><span style=display:flex><span>name = <span style=color:#f1fa8c>&#34;user-server&#34;</span>
</span></span><span style=display:flex><span>path = <span style=color:#f1fa8c>&#34;src/user/server.rs&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[[bin]]
</span></span><span style=display:flex><span>name = <span style=color:#f1fa8c>&#34;user-client&#34;</span>
</span></span><span style=display:flex><span>path = <span style=color:#f1fa8c>&#34;src/user/client.rs&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[dependencies]
</span></span><span style=display:flex><span>tonic = <span style=color:#f1fa8c>&#34;0.7.2&#34;</span>
</span></span><span style=display:flex><span>tokio = { version = <span style=color:#f1fa8c>&#34;1.18.2&#34;</span>, features = [<span style=color:#f1fa8c>&#34;macros&#34;</span>, <span style=color:#f1fa8c>&#34;rt-multi-thread&#34;</span>] }
</span></span><span style=display:flex><span>prost = <span style=color:#f1fa8c>&#34;0.10&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[build-dependencies]
</span></span><span style=display:flex><span>tonic-build = <span style=color:#f1fa8c>&#34;0.7.2&#34;</span>
</span></span></code></pre></div><p>创建下列文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ mkdir -p proto/user src/user
</span></span><span style=display:flex><span>$ touch build.rs proto/user/user.proto src/user/<span style=color:#ff79c6>{</span>server.rs,client.rs<span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>当前目录结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ tree -L <span style=color:#bd93f9>3</span>
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── Cargo.lock
</span></span><span style=display:flex><span>├── Cargo.toml
</span></span><span style=display:flex><span>├── build.rs <span style=color:#6272a4># Cargo 构建脚本</span>
</span></span><span style=display:flex><span>├── proto
</span></span><span style=display:flex><span>│   └── user
</span></span><span style=display:flex><span>│       └── user.proto <span style=color:#6272a4># proto 文件</span>
</span></span><span style=display:flex><span>└── src
</span></span><span style=display:flex><span>    └── user
</span></span><span style=display:flex><span>        ├── client.rs <span style=color:#6272a4># gRPC 客户端代码</span>
</span></span><span style=display:flex><span>        └── server.rs <span style=color:#6272a4># gRPC 服务端代码</span>
</span></span></code></pre></div><p>分别将以下内容拷贝到各个文件：</p><ul><li>proto/user/user.proto</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span>syntax <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;proto3&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>package</span> user;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>service</span> User {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>rpc</span> Hello (HelloRequest) <span style=color:#ff79c6>returns</span> (HelloReply) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>HelloRequest</span> {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>string</span> name <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>HelloReply</span> {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>string</span> <span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>src/user/server.rs</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> tonic::{transport::Server, Request, Response, Status};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> user::user_server::{User, UserServer};
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> user::{HelloReply, HelloRequest};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>mod</span> user {
</span></span><span style=display:flex><span>    tonic::include_proto<span style=color:#ff79c6>!</span>(<span style=color:#f1fa8c>&#34;user&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[derive(Default)]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>UserService</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[tonic::async_trait]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>impl</span> User <span style=color:#ff79c6>for</span> UserService {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>hello</span>(<span style=color:#ff79c6>&amp;</span>self, request: <span style=color:#50fa7b>Request</span><span style=color:#ff79c6>&lt;</span>HelloRequest<span style=color:#ff79c6>&gt;</span>) -&gt; <span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>Response<span style=color:#ff79c6>&lt;</span>HelloReply<span style=color:#ff79c6>&gt;</span>, Status<span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#f1fa8c>&#34;New user request from {:?}&#34;</span>, request.remote_addr());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>let</span> reply <span style=color:#ff79c6>=</span> user::HelloReply {
</span></span><span style=display:flex><span>            message: <span style=color:#50fa7b>format</span><span style=color:#ff79c6>!</span>(<span style=color:#f1fa8c>&#34;Hello {}!&#34;</span>, request.into_inner().name),
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>Ok</span>(Response::new(reply))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() -&gt; <span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>(), <span style=color:#8be9fd;font-style:italic>Box</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>dyn</span> std::error::Error<span style=color:#ff79c6>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> addr <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;127.0.0.1:50051&#34;</span>.parse().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> user_service <span style=color:#ff79c6>=</span> UserService::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#f1fa8c>&#34;UserService listening on {}&#34;</span>, addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Server::builder()
</span></span><span style=display:flex><span>        .add_service(UserServer::new(user_service))
</span></span><span style=display:flex><span>        .serve(addr)
</span></span><span style=display:flex><span>        .<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Ok</span>(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>src/user/client.rs</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> user::user_client::UserClient;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> user::HelloRequest;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>mod</span> user {
</span></span><span style=display:flex><span>    tonic::include_proto<span style=color:#ff79c6>!</span>(<span style=color:#f1fa8c>&#34;user&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() -&gt; <span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>(), <span style=color:#8be9fd;font-style:italic>Box</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>dyn</span> std::error::Error<span style=color:#ff79c6>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> <span style=color:#ff79c6>mut</span> client <span style=color:#ff79c6>=</span> UserClient::connect(<span style=color:#f1fa8c>&#34;http://127.0.0.1:50051&#34;</span>).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> request <span style=color:#ff79c6>=</span> tonic::Request::new(HelloRequest {
</span></span><span style=display:flex><span>        name: <span style=color:#f1fa8c>&#34;Rick&#34;</span>.into(),
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> response <span style=color:#ff79c6>=</span> client.hello(request).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#f1fa8c>&#34;RESPONSE={:?}&#34;</span>, response);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Ok</span>(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>build.rs</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> std::{env, path::PathBuf};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> out_dir <span style=color:#ff79c6>=</span> PathBuf::from(env::var(<span style=color:#f1fa8c>&#34;OUT_DIR&#34;</span>).unwrap());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> user_proto <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;proto/user/user.proto&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tonic_build::configure()
</span></span><span style=display:flex><span>        .build_server(<span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>        .build_client(<span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>        .out_dir(<span style=color:#ff79c6>&amp;</span>out_dir)
</span></span><span style=display:flex><span>        .file_descriptor_set_path(<span style=color:#ff79c6>&amp;</span>out_dir.join(<span style=color:#f1fa8c>&#34;user_descriptor.bin&#34;</span>))
</span></span><span style=display:flex><span>        .compile(<span style=color:#ff79c6>&amp;</span>[user_proto], <span style=color:#ff79c6>&amp;</span>[<span style=color:#f1fa8c>&#34;proto&#34;</span>])
</span></span><span style=display:flex><span>        .unwrap_or_else(<span style=color:#ff79c6>|</span>err<span style=color:#ff79c6>|</span> panic!(<span style=color:#f1fa8c>&#34;protobuf compile failed: {}&#34;</span>, err));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>尝试编译代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo build                
</span></span><span style=display:flex><span>   Compiling proc-macro2 v1.0.39
</span></span><span style=display:flex><span>   Compiling unicode-ident v1.0.0
</span></span><span style=display:flex><span>   Compiling syn v1.0.95
</span></span><span style=display:flex><span>   Compiling libc v0.2.126
</span></span><span style=display:flex><span>   Compiling cfg-if v1.0.0
</span></span><span style=display:flex><span>   Compiling log v0.4.17
</span></span><span style=display:flex><span>   <span style=color:#6272a4># ... 省略</span>
</span></span><span style=display:flex><span>   Compiling hyper v0.14.19
</span></span><span style=display:flex><span>   Compiling axum v0.5.6
</span></span><span style=display:flex><span>   Compiling hyper-timeout v0.4.1
</span></span><span style=display:flex><span>   Compiling tonic v0.7.2
</span></span><span style=display:flex><span>    Finished dev <span style=color:#ff79c6>[</span>unoptimized + debuginfo<span style=color:#ff79c6>]</span> target<span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>)</span> in 21.01s
</span></span></code></pre></div><p>如果编译通过，现在我们可以尝试执行编译好的程序了。</p><p>首先启动 gRPC 服务端程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run --bin user-server
</span></span><span style=display:flex><span>    Finished dev <span style=color:#ff79c6>[</span>unoptimized + debuginfo<span style=color:#ff79c6>]</span> target<span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>)</span> in 0.04s
</span></span><span style=display:flex><span>     Running <span style=color:#f1fa8c>`</span>target/debug/user-server<span style=color:#f1fa8c>`</span>
</span></span><span style=display:flex><span>UserService listening on 127.0.0.1:50051
</span></span></code></pre></div><p>重新打开一个 terminal 窗口并执行客户端程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run --bin user-client
</span></span><span style=display:flex><span>    Finished dev <span style=color:#ff79c6>[</span>unoptimized + debuginfo<span style=color:#ff79c6>]</span> target<span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>)</span> in 0.05s
</span></span><span style=display:flex><span>     Running <span style=color:#f1fa8c>`</span>target/debug/user-client<span style=color:#f1fa8c>`</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>RESPONSE</span><span style=color:#ff79c6>=</span>Response <span style=color:#ff79c6>{</span> metadata: MetadataMap <span style=color:#ff79c6>{</span> headers: <span style=color:#ff79c6>{</span><span style=color:#f1fa8c>&#34;content-type&#34;</span>: <span style=color:#f1fa8c>&#34;application/grpc&#34;</span>, <span style=color:#f1fa8c>&#34;date&#34;</span>: <span style=color:#f1fa8c>&#34;Sun, 29 May 2022 21:54:18 GMT&#34;</span>, <span style=color:#f1fa8c>&#34;grpc-status&#34;</span>: <span style=color:#f1fa8c>&#34;0&#34;</span><span style=color:#ff79c6>}</span> <span style=color:#ff79c6>}</span>, message: HelloReply <span style=color:#ff79c6>{</span> message: <span style=color:#f1fa8c>&#34;Hello Rick!&#34;</span> <span style=color:#ff79c6>}</span>, extensions: Extensions <span style=color:#ff79c6>}</span> <span style=color:#6272a4># &lt;- 客户端请求成功并返回响应</span>
</span></span></code></pre></div><p>此时我们切回服务端 terminal 窗口查看日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#6272a4># ...</span>
</span></span><span style=display:flex><span>UserService listening on 127.0.0.1:50051
</span></span><span style=display:flex><span>New user request from Some<span style=color:#ff79c6>(</span>127.0.0.1:52147<span style=color:#ff79c6>)</span> <span style=color:#6272a4># &lt;- 客户端调用成功</span>
</span></span></code></pre></div><p>至此，一个简单的基于 Rust 的 gRPC 服务端/客户端就实现了。上述代码很简陋，相信只要是接触过 gRPC 的同学都比较容易就可以理解。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://lvlv.fun/tags/grpc/>gRPC</a></li><li><a href=https://lvlv.fun/tags/rust/>Rust</a></li><li><a href=https://lvlv.fun/tags/microservices/>Microservices</a></li></ul><nav class=paginav><a class=next href=https://lvlv.fun/posts/2022-05-21/><span class=title>Next »</span><br><span>JavaScript 批量删除 Bilibili 动态</span></a></nav></footer><div id=comments-container><div id=comments-editor><div class=comments-editor-header><label for=comments-editor-nickname></label>
<input type=text id=comments-editor-nickname class=comments-editor-text placeholder=" 昵称 " maxlength=10 required>
<label for=comments-editor-email></label>
<input type=text id=comments-editor-email class=comments-editor-text placeholder=" 邮箱 " maxlength=20 required>
<button id=comments-editor-submit-button class=comments-editor-submit-button>提交</button></div><div class=comments-editor-body><label for=comments-editor-content></label>
<input type=text id=comments-editor-content class=comments-editor-text placeholder=" 留言... " maxlength=200 required></div></div><div id=comments-board></div><button id=comments-board-load-button>加载更多</button></div><script>let baseCommentURL='https://api.lvlv.fun/comment/v1',currentURL=window.location.href.split('?')[0],nickname=document.getElementById('comments-editor-nickname'),email=document.getElementById('comments-editor-email'),content=document.getElementById('comments-editor-content'),submitButton=document.getElementById('comments-editor-submit-button'),commentBoard=document.getElementById('comments-board'),loadButton=document.getElementById('comments-board-load-button'),currentPage=1,currentLimit=10;submitButton.addEventListener('click',function(){sendComment()}),loadButton.addEventListener('click',function(){currentPage+=1,getCommentRequest(currentPage,currentLimit)});function sendComment(){let s=null,e=null,t=content.value,n=t.split(' ');if(n.length>1&&!!n[0].match(/^@\d+$/g)){let o=n[0],i=t.slice(o.length+1,t.length);s=o.split('@')[1],e=i}else e=content.value;if(nickname.value===''||nickname.value.length<3||nickname.value.length>10){alert('请检查昵称');return}if(email.value===''){alert('请检查邮箱');return}if(content.value===''||content.value.length<3||content.value.length>200){alert('请检查留言');return}sendCommentRequest(nickname.value,email.value,e,s)}function sendCommentRequest(n,s,o,t){let e=baseCommentURL+'/add'+'?nickname='+n+'&email='+s+'&content='+o;t&&(e=e+'&parentId='+t),fetch(e,{headers:{'Origin-Url':currentURL}}).then(e=>{if(e.ok)return e.json();throw new Error('请求失败')}).then(e=>{e.code!==void 0?alert(e.message):(formatOnceComment(e.comment),content.value='')}).catch(e=>{console.log(e),alert('参数错误，请检查提交内容')})}function getCommentRequest(e,t){fetch(baseCommentURL+'/list'+'?page='+e+'&limit='+t,{headers:{'Origin-Url':currentURL}}).then(e=>e.json()).then(e=>{e.code!==void 0?alert(e.message):e.comments&&(formatComment(e.comments),document.getElementsByClassName('comments-board-item').length<parseInt(e.total)&&(loadButton.style.display='block'))}).catch(e=>{console.log('Error:'+e)})}function buildBoardItem(e){let a=document.createElement('div'),l=document.createElement('img'),o=document.createElement('div'),n=document.createElement('div'),r=document.createElement('div'),u=document.createElement('span'),f=document.createElement('span'),c=document.createElement('span'),s=document.createElement('span'),d=document.createElement('span'),i=document.createElement('a'),h=document.createElement('div'),m=document.createElement('p'),t=document.createElement('div');a.classList.add('comments-board-item'),l.classList.add('comments-board-item-avatar'),o.classList.add('comments-board-item-title'),n.classList.add('comments-board-item-user'),r.classList.add('comments-board-item-info'),u.classList.add('comments-board-item-id'),f.classList.add('comments-board-item-nickname'),c.classList.add('comments-board-item-role'),s.classList.add('comments-board-item-ua'),d.classList.add('comments-board-item-date'),i.classList.add('comments-board-item-reply'),h.classList.add('comments-board-item-meta'),m.classList.add('comments-board-item-content');for(let o=0;o<e.children.length;o++){if(o===0){let e=document.createElement('hr');e.classList.add('comments-board-item-children-line'),t.appendChild(e)}let n=e.children[o],f=n.id,m=n.nickname,u=n.role,d=n.userAgent,h=n.content,p=formatDate(n.createdAt),c=document.createElement('span'),r=document.createElement('span'),i=document.createElement('span'),s=document.createElement('span'),a=document.createElement('span'),l=document.createElement('p');c.classList.add('comments-board-item-id'),r.classList.add('comments-board-item-nickname'),i.classList.add('comments-board-item-role'),s.classList.add('comments-board-item-ua'),a.classList.add('comments-board-item-date'),l.classList.add('comments-board-item-content'),c.innerText='#'+f,r.innerText=m,i.innerText=u,s.innerText=d,a.innerText=p,l.innerText=h,t.appendChild(c),t.appendChild(r),t.appendChild(i),t.appendChild(s),t.appendChild(a),t.appendChild(l),u!=='admin'&&(s.innerText=formatUserAgent(d),t.removeChild(i)),s.innerText="via "+s.innerText}return l.src="https://source.boringavatars.com/beam/40/test"+e.nickname,u.innerText='#'+e.id,f.innerText=e.nickname,c.innerText=e.role,s.innerText=e.userAgent,d.innerText=formatDate(e.createdAt),i.innerText='reply',i.href='javascript:void(0)',i.onclick=function(){e.id&&(content.value='@'+e.id+' ',content.focus())},m.innerText=e.content,n.appendChild(u),n.appendChild(f),n.appendChild(c),n.appendChild(i),r.appendChild(s),r.appendChild(d),o.appendChild(l),o.appendChild(n),o.appendChild(r),h.appendChild(m),e.role!=='admin'&&(s.innerText=formatUserAgent(e.userAgent),n.removeChild(c)),s.innerText="via "+s.innerText,a.appendChild(o),a.appendChild(h),a.appendChild(t),a}function formatUserAgent(t){let e='unknown';return t.match(/Macintosh/gi)?e='Macintosh':t.match(/iPod/gi)?e='iPod':t.match(/iPad/gi)?e='iPad':t.match(/iPhone/gi)?e='iPhone':t.match(/Android/gi)?e='Android':t.match(/Windows/gi)?e='Windows':!t.match(/Linux/gi)||(e='Linux'),e}function formatOnceComment(e){if(e.parentId!==0)commentBoard.innerHTML='',getCommentRequest(currentPage,currentLimit);else{let n=buildBoardItem(e);commentBoard.insertBefore(n,document.getElementsByClassName('comments-board-item')[0]);let t=document.getElementsByClassName('comments-board-item')[currentLimit];t!==void 0&&commentBoard.removeChild(t)}}function formatComment(e){if(!e||e.length<=0)return;for(let t=0;t<e.length;t++){let n=buildBoardItem(e[t]);commentBoard.appendChild(n)}}function formatDate(n){let s=new Date(n).getTime(),t=Math.floor((new Date-s)/1e3),e=t/86400;return e>1?Math.floor(e)+'天前':(e=t/3600,e>1?Math.floor(e)+'小时前':(e=t/60,e>1?Math.floor(e)+'分钟前':e<0?'前阵子':Math.floor(t)+'秒前'))}getCommentRequest(currentPage,currentLimit)</script></article></main><footer class=footer><span>&copy; 2022 <a href=https://lvlv.fun>Lv's Playground</a></span>
<span>|</span>
<span><a href=https://beian.miit.gov.cn/>皖ICP备2022006072号-1</a></span>
<span>|</span>
<span><img style=display:inline;margin-bottom:-.8em src="https://matomo.lvlv.fun/index.php?module=FlagCounter&action=image&idSite=1&period=range&date=last365&sort=popular&activated=&rows=1&cols=1&showcode=1&showflag=0&fontsize=8&fontcolor=218,218,219&font=Roboto-Regular" alt=flag></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll('pre > code').forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement('button');e.classList.add('copy-code'),e.innerHTML='copy';function s(){e.innerHTML='copied!',setTimeout(()=>{e.innerHTML='copy'},2e3)}e.addEventListener('click',o=>{if('clipboard'in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand('copy'),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>