<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Learning go from zero to hero - Part 2 | Lv's Playground</title><meta name=keywords content="Go"><meta name=description content="作者：Milap Neupane
链接：https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86
函数 main.go包中定义的func main()是执行程序的入口。可以定义和使用更多函数。让我们看一个简单的例子：
func add(a int, b int) int { c := a + b return c } func main() { fmt.Println(add(2, 1)) } // 3 正如我们在上面的例子中所看到的，使用**func关键字后跟函数名来定义Go函数。函数所需的参数**需要根据其数据类型定义，最后是返回的数据类型。
函数的返回也可以在函数中预定义：
func add(a int, b int) (c int) { c = a + b return } func main() { fmt.Println(add(2, 1)) } // 3 这里c被定义为返回变量。因此，定义的变量c将自动返回，而无需在结尾的return语句中定义。
还可以从单个函数返回多个返回值，将返回值与逗号分隔开。
func add(a int, b int) (int, string) { c := a + b return c, &#34;successfully added&#34; } func main() { sum, message := add(2, 1) fmt."><meta name=author content="L"><link rel=canonical href=https://lvlv.fun/posts/2018-12-28/><link crossorigin=anonymous href=/assets/css/stylesheet.b4f4fc654d72a2d0804f53f415d899fa9b42f6ea7f47816024f38db8206ed58b.css integrity="sha256-tPT8ZU1yotCAT1P0FdiZ+ptC9up/R4FgJPONuCBu1Ys=" rel="preload stylesheet" as=style><link rel=icon href=https://lvlv.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lvlv.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lvlv.fun/favicon-32x32.png><link rel=apple-touch-icon href=https://lvlv.fun/apple-touch-icon.png><link rel=mask-icon href=https://lvlv.fun/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var _paq=window._paq=window._paq||[];_paq.push(['trackPageView']),_paq.push(['enableLinkTracking']),function(){e="//matomo.lvlv.fun/",_paq.push(['setTrackerUrl',e+'matomo.php']),_paq.push(['setSiteId','1']);var e,n=document,t=n.createElement('script'),s=n.getElementsByTagName('script')[0];t.async=!0,t.src=e+'matomo.js',s.parentNode.insertBefore(t,s)}()</script><meta property="og:title" content="Learning go from zero to hero - Part 2"><meta property="og:description" content="作者：Milap Neupane
链接：https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86
函数 main.go包中定义的func main()是执行程序的入口。可以定义和使用更多函数。让我们看一个简单的例子：
func add(a int, b int) int { c := a + b return c } func main() { fmt.Println(add(2, 1)) } // 3 正如我们在上面的例子中所看到的，使用**func关键字后跟函数名来定义Go函数。函数所需的参数**需要根据其数据类型定义，最后是返回的数据类型。
函数的返回也可以在函数中预定义：
func add(a int, b int) (c int) { c = a + b return } func main() { fmt.Println(add(2, 1)) } // 3 这里c被定义为返回变量。因此，定义的变量c将自动返回，而无需在结尾的return语句中定义。
还可以从单个函数返回多个返回值，将返回值与逗号分隔开。
func add(a int, b int) (int, string) { c := a + b return c, &#34;successfully added&#34; } func main() { sum, message := add(2, 1) fmt."><meta property="og:type" content="article"><meta property="og:url" content="https://lvlv.fun/posts/2018-12-28/"><meta property="og:image" content="https://lvlv.fun/apple-touch-icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-28T13:34:06+08:00"><meta property="article:modified_time" content="2018-12-28T13:34:06+08:00"><meta property="og:site_name" content="Lv's Playground"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lvlv.fun/apple-touch-icon.png"><meta name=twitter:title content="Learning go from zero to hero - Part 2"><meta name=twitter:description content="作者：Milap Neupane
链接：https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86
函数 main.go包中定义的func main()是执行程序的入口。可以定义和使用更多函数。让我们看一个简单的例子：
func add(a int, b int) int { c := a + b return c } func main() { fmt.Println(add(2, 1)) } // 3 正如我们在上面的例子中所看到的，使用**func关键字后跟函数名来定义Go函数。函数所需的参数**需要根据其数据类型定义，最后是返回的数据类型。
函数的返回也可以在函数中预定义：
func add(a int, b int) (c int) { c = a + b return } func main() { fmt.Println(add(2, 1)) } // 3 这里c被定义为返回变量。因此，定义的变量c将自动返回，而无需在结尾的return语句中定义。
还可以从单个函数返回多个返回值，将返回值与逗号分隔开。
func add(a int, b int) (int, string) { c := a + b return c, &#34;successfully added&#34; } func main() { sum, message := add(2, 1) fmt."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://lvlv.fun/posts/"},{"@type":"ListItem","position":3,"name":"Learning go from zero to hero - Part 2","item":"https://lvlv.fun/posts/2018-12-28/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Learning go from zero to hero - Part 2","name":"Learning go from zero to hero - Part 2","description":"作者：Milap Neupane\n链接：https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86\n函数 main.go包中定义的func main()是执行程序的入口。可以定义和使用更多函数。让我们看一个简单的例子：\nfunc add(a int, b int) int { c := a + b return c } func main() { fmt.Println(add(2, 1)) } // 3 正如我们在上面的例子中所看到的，使用**func关键字后跟函数名来定义Go函数。函数所需的参数**需要根据其数据类型定义，最后是返回的数据类型。\n函数的返回也可以在函数中预定义：\nfunc add(a int, b int) (c int) { c = a + b return } func main() { fmt.Println(add(2, 1)) } // 3 这里c被定义为返回变量。因此，定义的变量c将自动返回，而无需在结尾的return语句中定义。\n还可以从单个函数返回多个返回值，将返回值与逗号分隔开。\nfunc add(a int, b int) (int, string) { c := a + b return c, \u0026#34;successfully added\u0026#34; } func main() { sum, message := add(2, 1) fmt.","keywords":["Go"],"articleBody":" 作者：Milap Neupane\n链接：https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86\n函数 main.go包中定义的func main()是执行程序的入口。可以定义和使用更多函数。让我们看一个简单的例子：\nfunc add(a int, b int) int { c := a + b return c } func main() { fmt.Println(add(2, 1)) } // 3 正如我们在上面的例子中所看到的，使用**func关键字后跟函数名来定义Go函数。函数所需的参数**需要根据其数据类型定义，最后是返回的数据类型。\n函数的返回也可以在函数中预定义：\nfunc add(a int, b int) (c int) { c = a + b return } func main() { fmt.Println(add(2, 1)) } // 3 这里c被定义为返回变量。因此，定义的变量c将自动返回，而无需在结尾的return语句中定义。\n还可以从单个函数返回多个返回值，将返回值与逗号分隔开。\nfunc add(a int, b int) (int, string) { c := a + b return c, \"successfully added\" } func main() { sum, message := add(2, 1) fmt.Println(message) fmt.Println(sum) } 结构、方法和接口 Go不是一个完全面向对象的语言，但是它的结构，接口和方法，和面向对象有异曲同工之妙。\n结构 结构struct是不同类型字段的集合。结构用于将数据分组在一起。例如，如果我们想要对Person类型的数据进行分组，我们会定义一个人的属性，其中可能包括姓名，年龄，性别。可以使用以下语法定义结构：\ntype person struct { name string age int gender string } 在定义了人类型结构的情况下，现在让我们创建一个person：\n//方式1：指定属性和值 p = person{name: \"Bob\", age: 42, gender: \"Male\"} //方式2：仅指定值 person{\"Bob\", 42, \"Male\"} 我们可以用点.轻松访问这些数据\np.name // Bob p.age // 42 p.gender // Male 还可以使用其指针直接访问结构的属性：\npp = \u0026person{name: \"Bob\", age: 42, gender: \"Male\"} pp.name // Bob 方法 方法Method是具有接收器的特殊类型的功能*。*接收器既可以是值，也可以是指针。让我们创建一个名为describe的方法，它具有我们在上面的例子中创建的接收器类型：\npackage main import \"fmt\" // struct defination type person struct { name string age int gender string } // method 定义 func (p *person) describe() { fmt.Printf(\"%v is %v years old.\", p.name, p.age) } func (p *person) setAge(age int) { p.age = age } func (p person) setName(name string) { p.name = name } func main() { pp := \u0026person{name: \"Bob\", age: 42, gender: \"Male\"} pp.describe() // =\u003e Bob is 42 years old pp.setAge(45) fmt.Println(pp.age) // 45 pp.setName(\"Hari\") fmt.Println(pp.name) // Bob } 正如我们在上面的例子中所看到的，现在可以使用点运算符调用该方法pp.describe。请注意，接收器是指针。使用指针，我们传递对值的引用，因此如果我们在方法中进行任何更改，它将反映在接收器pp中。它也不会创建对象的新副本，这样可以节省内存开销。\n请注意，在上面的示例中，age的值已更改，而name的值未更改，因为方法setName属于接收器类型，而setAge属于指针类型。\n接口 Go接口interface是方法的集合。接口有助于将类型的属性组合在一起。我们以接口animal为例：\ntype animal interface { description() string } 这里的animal是一种接口interface类型。现在我们创建两种不同类型的动物来实现animal接口类型：\npackage main import ( \"fmt\" ) type animal interface { description() string } type cat struct { Type string Sound string } type snake struct { Type string Poisonous bool } func (s snake) description() string { return fmt.Sprintf(\"Poisonous: %v\", s.Poisonous) } func (c cat) description() string { return fmt.Sprintf(\"Sound: %v\", c.Sound) } func main() { var a animal a = snake{Poisonous: true} fmt.Println(a.description()) a = cat{Sound: \"Meow!!!\"} fmt.Println(a.description()) } // Poisonous: true // Sound: Meow!!! 在main函数中，我们创建了一个a类型为animal的变量。我们为动物分配蛇和猫类型，并使用Println打印a.description()。由于我们以不同的方式实现了两种类型（猫和蛇）中描述的方法，我们得到了不同动物的属性。\n包 我们在Go中编写所有代码。main包是程序执行的入口点。Go中有很多内置包Package。我们一直使用的就是著名的fmt包。\n在主要机制中使用Go的包进行大规模编程，可以将大型项目分成更小的部分。\n安装包 go get // 示例 go get github.com/satori/go.uuid 我们安装的软件包保存在GOPATH env中，这是我们的工作目录。通过我们的工作目录中的pkg文件夹进入包cd $GOPATH/pkg。\n创建自定义包 让我们从创建一个文件夹custom_package开始：\n\u003e mkdir custom_package \u003e cd custom_package 要创建自定义包，我们需要先使用我们需要的包名创建一个文件夹。假设我们正在构建一个包person。我们在custom_package目录中创建一个名为person的目录\n\u003e mkdir person \u003e cd person 现在让我们在这个文件夹中创建一个文件person.go。\npackage person func Description(name string) string { return \"The person name is: \" + name } func secretName(name string) string { return \"Do not share\" } 我们现在需要安装包，以便可以导入和使用它。所以让我们安装它：\n\u003e go install 现在让我们回到custom_package文件夹并创建一个main.go文件\npackage main import( \"custom_package/person\" \"fmt\" ) func main(){ p := person.Description(\"Milap\") fmt.Println(p) } // =\u003e The person name is: Milap 现在我们可以导入person我们创建的包并使用函数Description。请注意，secretName我们在包中创建的功能将无法访问。在Go中，以大写字母开头的方法名称将是私有的private。\n包文档 Go内置了对包文档的支持。运行以下命令以生成文档：\ngodoc person Description 这将为我们的包人员生成Description函数的文档。要查看文档，请使用以下命令运行Web服务器：\ngodoc -http=\":8080\" 现在转到http://localhost:8080/pkg查看我们刚创建的包的文档。\nGo的内置包 fmt 该包实现了格式化的I/O功能，我们已经使用该包打印出stdout。\njson Go中另一个有用的包是json包。用于编码/解码JSON。让我们举个例子来编码/解码json：\n编码\npackage main import ( \"fmt\" \"encoding/json\" ) func main(){ mapA := map[string]int{\"apple\": 5, \"lettuce\": 7} mapB, _ := json.Marshal(mapA) fmt.Println(string(mapB)) } 解码\npackage main import ( \"fmt\" \"encoding/json\" ) type response struct { PageNumber int `json:\"page\"` Fruits []string `json:\"fruits\"` } func main(){ str := `{\"page\": 1, \"fruits\": [\"apple\", \"peach\"]}` res := response{} json.Unmarshal([]byte(str), \u0026res) fmt.Println(res.PageNumber) } // 1 在使用Unmarshal解码json字符串时，第一个参数是json字符串，第二个参数是我们希望json映射到的响应类型struct的地址。请注意，json:\"page\"映射页面键是结构中的PageNumber键。\n错误处理 Error 错误Error是程序不被希望出现的意外的结果。假设我们正在对外部服务进行API调用，此API调用可能成功也可能失败。当存在错误类型时，我们就可以识别Go程序中的错误。看看下面这个例子：\nresp, err := http.Get(\"http://example.com/\") 这里对错误对象的API调用可能会成功或失败。我们可以检查错误是否为nil，并处理响应：\npackage main import ( \"fmt\" \"net/http\" ) func main(){ resp, err := http.Get(\"http://example.com/\") if err != nil { fmt.Println(err) return } fmt.Println(resp) } 自定义错误 当我们编写自己的函数时，有些情况下我们会遇到错误。可以在错误对象的帮助下返回这些错误：\nfunc Increment(n int) (int, error) { if n \u003c 0 { // return error object return nil, errors.New(\"math: cannot process negative number\") } return (n + 1), nil } func main() { num := 5 if inc, err := Increment(num); err != nil { fmt.Printf(\"Failed Number: %v, error message: %v\", num, err) }else { fmt.Printf(\"Incremented Number: %v\", inc) } } 在Go中构建的大多数包或我们使用的外部包都有错误处理机制。所以我们调用的任何函数都可能存在错误。这些错误永远不应该被忽略，并且总是在我们称之为函数的地方优雅地处理，就像我们在上面的例子中所做的那样。\nPanic panic是一种未经处理的事件，在程序执行期间突然遇到。在Go中，panic不是处理程序中异常的理想方式。建议使用错误对象。发生panic时程序会停止执行。panic之后执行的事件就是defer。\nDefer defer总是在函数结束时执行。\npackage main import \"fmt\" func main() { f() fmt.Println(\"Returned normally from f.\") } func f() { defer func() { if r := recover(); r != nil { fmt.Println(\"Recovered in f\", r) } }() fmt.Println(\"Calling g.\") g(0) fmt.Println(\"Returned normally from g.\") } func g(i int) { if i \u003e 3 { fmt.Println(\"Panicking!\") panic(fmt.Sprintf(\"%v\", i)) } defer fmt.Println(\"Defer in g\", i) fmt.Println(\"Printing in g\", i) g(i + 1) } 在上面的例子中，我们使用panic()来故意终止程序的执行。正如你所注意到的，有一个defer语句，它将使程序在程序执行结束时执行该行。当我们需要在函数结束时执行某些操作时，也可以使用defer，例如关闭文件。\n并发 Go是建立在并发性的基础上的。Go中的并发可以通过轻量级线程的Go例程来实现。\n协程(go routine) go协程routine是可以与另一个函数并行或同时运行的函数。创建go协程非常简单。只需在函数前面添加关键字go，我们就可以使它并行执行。go协程非常轻量级，因此我们可以创建数千个协程。让我们看一个简单的例子：\npackage main import ( \"fmt\" \"time\" ) func main() { go c() fmt.Println(\"I am main\") time.Sleep(time.Second * 2) } func c() { time.Sleep(time.Second * 2) fmt.Println(\"I am concurrent\") } // I am main // I am concurrent 正如上面的示例，函数c()是一个Go协程，它与主Go线程并行执行。有时我们希望在多个线程之间共享资源。Go更倾向于一个线程的变量不与另一个线程共享，因为这会增加死锁和资源等待的可能性。还有另一种在Go协程之间共享资源的方法：管道Channels。\n管道（channel） 我们可以使用通道在两个Go协程之间传递数据。在创建channel时，必须指定channel接收的数据类型。让我们创建一个字符串类型的简单channel，如下所示：\nc := make(chan string) 使用此channel，我们可以发送字符串类型数据。可以在此频道中发送和接收数据：\npackage main import \"fmt\" func main(){ c := make(chan string) go func(){ c \u003c- \"hello\" }() msg := \u003c-c fmt.Println(msg) } //\"hello\" 接收方等待发送方向channel发送数据。\n单向通道 在某些情况下，我们希望Go协程通过channel接收数据但不发送数据，反之亦然。为此，我们还可以创建单向通道。让我们看一个简单的例子：\npackage main import ( \"fmt\" ) func main() { ch := make(chan string) go sc(ch) fmt.Println(\u003c-ch) } func sc(ch chan\u003c- string) { ch \u003c- \"hello\" } 在上面的例子中，sc是一个Go协程，它只能向通道发送消息但不能接收消息。\n使用select为Go例程组织多个通道 函数可能有多个通道正在等待执行。为此，我们可以使用select语句。让我们看一个更清晰的例子：：\npackage main import ( \"fmt\" \"time\" ) func main() { c1 := make(chan string) c2 := make(chan string) go speed1(c1) go speed2(c2) fmt.Println(\"The first to arrive is:\") select { case s1 := \u003c-c1: fmt.Println(s1) case s2 := \u003c-c2: fmt.Println(s2) } } func speed1(ch chan string) { time.Sleep(2 * time.Second) ch \u003c- \"speed 1\" } func speed2(ch chan string) { time.Sleep(1 * time.Second) ch \u003c- \"speed 2\" } 在上面的示例中，main正在等待两个管道c1和c2。使用select case语句打印主函数，消息从管道发送，无论它先收到哪个。\n缓冲通道 有些情况下我们需要向管道发送多个数据。可以为此创建缓冲通道buffered channel。使用缓冲通道，接收器在缓冲区已满之前不会收到消息。我们来看看这个例子：\npackage main import \"fmt\" func main(){ ch := make(chan string, 2) ch \u003c- \"hello\" ch \u003c- \"world\" fmt.Println(\u003c-ch) } 结尾 为什么Golang会成功?\n简单… — Rob-pike\n目前为止我们已经了解了Go的一些主要组件和功能：\n变量，数据类型 Array、Slices和Map 函数 循环和条件语句 指针 包 结构、方法和接口 错误处理 并发 - Go routine和channel 恭喜你，你现在对Go有了不错的认识。\n抛弃了1000行代码的那天是我最富有成效的日子之一。\n— Ken Thompson\n不要止步于此，继续前进。在大脑中思考一个小规模的应用程序并开始构建。\n","wordCount":"851","inLanguage":"en","datePublished":"2018-12-28T13:34:06+08:00","dateModified":"2018-12-28T13:34:06+08:00","author":{"@type":"Person","name":"L"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lvlv.fun/posts/2018-12-28/"},"publisher":{"@type":"Organization","name":"Lv's Playground","logo":{"@type":"ImageObject","url":"https://lvlv.fun/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://lvlv.fun accesskey=h title="Started (Alt + H)"><img src=https://lvlv.fun/apple-touch-icon.png alt aria-label=logo height=35>Started</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://lvlv.fun/navigation/ title=Navigation><span>Navigation</span></a></li><li><a href=https://lvlv.fun/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://lvlv.fun/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lvlv.fun>Home</a>&nbsp;»&nbsp;<a href=https://lvlv.fun/posts/>Posts</a></div><h1 class=post-title>Learning go from zero to hero - Part 2</h1><div class=post-meta><span title='2018-12-28 13:34:06 +0800 +0800'>2018-12-28</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;L&nbsp;|&nbsp;<a href=https://github.com/NERVEbing/blog/blob/master/content/posts/2018-12-28.md rel="noopener noreferrer" target=_blank>edit</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a></li><li><a href=#%e7%bb%93%e6%9e%84%e6%96%b9%e6%b3%95%e5%92%8c%e6%8e%a5%e5%8f%a3 aria-label=结构、方法和接口>结构、方法和接口</a><ul><li><a href=#%e7%bb%93%e6%9e%84 aria-label=结构>结构</a></li><li><a href=#%e6%96%b9%e6%b3%95 aria-label=方法><strong>方法</strong></a></li><li><a href=#%e6%8e%a5%e5%8f%a3 aria-label=接口>接口</a></li></ul></li><li><a href=#%e5%8c%85 aria-label=包>包</a><ul><li><a href=#%e5%ae%89%e8%a3%85%e5%8c%85 aria-label=安装包>安装包</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e8%87%aa%e5%ae%9a%e4%b9%89%e5%8c%85 aria-label=创建自定义包>创建自定义包</a></li><li><a href=#%e5%8c%85%e6%96%87%e6%a1%a3 aria-label=包文档><strong>包文档</strong></a></li><li><a href=#go%e7%9a%84%e5%86%85%e7%bd%ae%e5%8c%85 aria-label=Go的内置包>Go的内置包</a><ul><li><a href=#fmt aria-label=fmt><strong>fmt</strong></a></li><li><a href=#json aria-label=json><strong>json</strong></a></li></ul></li></ul></li><li><a href=#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86 aria-label=错误处理>错误处理</a><ul><li><a href=#error aria-label=Error>Error</a><ul><li><a href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e9%94%99%e8%af%af aria-label=自定义错误>自定义错误</a></li></ul></li><li><a href=#panic aria-label=Panic>Panic</a></li><li><a href=#defer aria-label=Defer>Defer</a></li></ul></li><li><a href=#%e5%b9%b6%e5%8f%91 aria-label=并发>并发</a><ul><li><a href=#%e5%8d%8f%e7%a8%8bgo-routine aria-label="协程(go routine)">协程(go routine)</a></li><li><a href=#%e7%ae%a1%e9%81%93channel aria-label=管道（channel）>管道（channel）</a></li><li><a href=#%e5%8d%95%e5%90%91%e9%80%9a%e9%81%93 aria-label=单向通道>单向通道</a></li><li><a href=#%e4%bd%bf%e7%94%a8select%e4%b8%bago%e4%be%8b%e7%a8%8b%e7%bb%84%e7%bb%87%e5%a4%9a%e4%b8%aa%e9%80%9a%e9%81%93 aria-label=使用select为Go例程组织多个通道>使用select为Go例程组织多个通道</a></li><li><a href=#%e7%bc%93%e5%86%b2%e9%80%9a%e9%81%93 aria-label=缓冲通道>缓冲通道</a></li></ul></li><li><a href=#%e7%bb%93%e5%b0%be aria-label=结尾>结尾</a></li></ul></div></details></div><div class=post-content><hr><p>作者：<a href=https://medium.freecodecamp.org/@milapneupane>Milap Neupane</a></p><p>链接：<a href=https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86>https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86</a></p><hr><h3 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h3><p>  <code>main.go</code>包中定义的<code>func main()</code>是执行程序的入口。可以定义和使用更多函数。让我们看一个简单的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>add</span>(a <span style=color:#8be9fd>int</span>, b <span style=color:#8be9fd>int</span>) <span style=color:#8be9fd>int</span> {
</span></span><span style=display:flex><span>  c <span style=color:#ff79c6>:=</span> a <span style=color:#ff79c6>+</span> b
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> c
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#50fa7b>add</span>(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// 3
</span></span></span></code></pre></div><p>  正如我们在上面的例子中所看到的，使用**<code>func</code><strong>关键字后跟函数名来定义Go函数。函数所需的</strong>参数**需要根据其数据类型定义，最后是返回的数据类型。</p><p>  函数的返回也可以在函数中预定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>add</span>(a <span style=color:#8be9fd>int</span>, b <span style=color:#8be9fd>int</span>) (c <span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>  c = a <span style=color:#ff79c6>+</span> b
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#50fa7b>add</span>(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// 3
</span></span></span></code></pre></div><p>  这里c被定义为返回变量。因此，定义的变量c将自动返回，而无需在结尾的return语句中定义。</p><p>  还可以从单个函数返回多个返回值，将返回值与逗号分隔开。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>add</span>(a <span style=color:#8be9fd>int</span>, b <span style=color:#8be9fd>int</span>) (<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>string</span>) {
</span></span><span style=display:flex><span>  c <span style=color:#ff79c6>:=</span> a <span style=color:#ff79c6>+</span> b
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> c, <span style=color:#f1fa8c>&#34;successfully added&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>  sum, message <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(message)
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(sum)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=结构方法和接口>结构、方法和接口<a hidden class=anchor aria-hidden=true href=#结构方法和接口>#</a></h3><p>  Go不是一个完全面向对象的语言，但是它的结构，接口和方法，和面向对象有异曲同工之妙。</p><h4 id=结构>结构<a hidden class=anchor aria-hidden=true href=#结构>#</a></h4><p>  结构<code>struct</code>是不同类型字段的集合。结构用于将数据分组在一起。例如，如果我们想要对<code>Person</code>类型的数据进行分组，我们会定义一个人的属性，其中可能包括姓名，年龄，性别。可以使用以下语法定义结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> person <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>  name <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>  age <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>  gender <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>  在定义了人类型结构的情况下，现在让我们创建一个<code>person</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>//方式1：指定属性和值
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>p = person{name: <span style=color:#f1fa8c>&#34;Bob&#34;</span>, age: <span style=color:#bd93f9>42</span>, gender: <span style=color:#f1fa8c>&#34;Male&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>//方式2：仅指定值
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>person{<span style=color:#f1fa8c>&#34;Bob&#34;</span>, <span style=color:#bd93f9>42</span>, <span style=color:#f1fa8c>&#34;Male&#34;</span>}
</span></span></code></pre></div><p>  我们可以用点<code>.</code>轻松访问这些数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>p.name
</span></span><span style=display:flex><span><span style=color:#6272a4>// Bob
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>p.age
</span></span><span style=display:flex><span><span style=color:#6272a4>// 42
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>p.gender
</span></span><span style=display:flex><span><span style=color:#6272a4>// Male
</span></span></span></code></pre></div><p>  还可以使用其指针直接访问结构的属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>pp = <span style=color:#ff79c6>&amp;</span>person{name: <span style=color:#f1fa8c>&#34;Bob&#34;</span>, age: <span style=color:#bd93f9>42</span>, gender: <span style=color:#f1fa8c>&#34;Male&#34;</span>}
</span></span><span style=display:flex><span>pp.name
</span></span><span style=display:flex><span><span style=color:#6272a4>// Bob
</span></span></span></code></pre></div><h4 id=方法><strong>方法</strong><a hidden class=anchor aria-hidden=true href=#方法>#</a></h4><p>  方法<code>Method</code>是具有<em>接收器</em>的特殊类型的功能*。*接收器既可以是值，也可以是指针。让我们创建一个名为describe的方法，它具有我们在上面的例子中创建的接收器类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// struct defination
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> person <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>  name   <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>  age    <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>  gender <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// method 定义
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>person) <span style=color:#50fa7b>describe</span>() {
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;%v is %v years old.&#34;</span>, p.name, p.age)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>person) <span style=color:#50fa7b>setAge</span>(age <span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>  p.age = age
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (p person) <span style=color:#50fa7b>setName</span>(name <span style=color:#8be9fd>string</span>) {
</span></span><span style=display:flex><span>  p.name = name
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>  pp <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>person{name: <span style=color:#f1fa8c>&#34;Bob&#34;</span>, age: <span style=color:#bd93f9>42</span>, gender: <span style=color:#f1fa8c>&#34;Male&#34;</span>}
</span></span><span style=display:flex><span>  pp.<span style=color:#50fa7b>describe</span>()
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// =&gt; Bob is 42 years old
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  pp.<span style=color:#50fa7b>setAge</span>(<span style=color:#bd93f9>45</span>)
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(pp.age)
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 45
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  pp.<span style=color:#50fa7b>setName</span>(<span style=color:#f1fa8c>&#34;Hari&#34;</span>)
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(pp.name)
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// Bob
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>  正如我们在上面的例子中所看到的，现在可以使用点运算符调用该方法<code>pp.describe</code>。请注意，接收器是指针。使用指针，我们传递对值的引用，因此如果我们在方法中进行任何更改，它将反映在接收器<code>pp</code>中。它也不会创建对象的新副本，这样可以节省内存开销。</p><p>  请注意，在上面的示例中，age的值已更改，而name的值未更改，因为方法setName属于接收器类型，而setAge属于指针类型。</p><h4 id=接口>接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h4><p>  Go接口<code>interface</code>是方法的集合。接口有助于将类型的属性组合在一起。我们以接口<code>animal</code>为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> animal <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>  <span style=color:#50fa7b>description</span>() <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>  这里的<code>animal</code>是一种接口<code>interface</code>类型。现在我们创建两种不同类型的动物来实现<code>animal</code>接口类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> animal <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>  <span style=color:#50fa7b>description</span>() <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> cat <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>  Type  <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>  Sound <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> snake <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>  Type      <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>  Poisonous <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (s snake) <span style=color:#50fa7b>description</span>() <span style=color:#8be9fd>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;Poisonous: %v&#34;</span>, s.Poisonous)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (c cat) <span style=color:#50fa7b>description</span>() <span style=color:#8be9fd>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;Sound: %v&#34;</span>, c.Sound)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>var</span> a animal
</span></span><span style=display:flex><span>  a = snake{Poisonous: <span style=color:#ff79c6>true</span>}
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(a.<span style=color:#50fa7b>description</span>())
</span></span><span style=display:flex><span>  a = cat{Sound: <span style=color:#f1fa8c>&#34;Meow!!!&#34;</span>}
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(a.<span style=color:#50fa7b>description</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Poisonous: true
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Sound: Meow!!!
</span></span></span></code></pre></div><p>  在<code>main</code>函数中，我们创建了一个<code>a</code>类型为<code>animal</code>的变量。我们为动物分配蛇和猫类型，并使用Println打印<code>a.description()</code>。由于我们以不同的方式实现了两种类型（猫和蛇）中描述的方法，我们得到了不同动物的属性。</p><h3 id=包>包<a hidden class=anchor aria-hidden=true href=#包>#</a></h3><p>  我们在Go中编写所有代码。<strong><code>main</code><strong>包是程序执行的入口点。Go中有很多内置包<code>Package</code>。我们一直使用的就是著名的</strong>fmt</strong>包。</p><blockquote><p>  在主要机制中使用Go的包进行大规模编程，可以将大型项目分成更小的部分。</p></blockquote><h4 id=安装包>安装包<a hidden class=anchor aria-hidden=true href=#安装包>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get &lt;package-url-github&gt;
</span></span><span style=display:flex><span>// 示例
</span></span><span style=display:flex><span>go get github.com/satori/go.uuid
</span></span></code></pre></div><p>  我们安装的软件包保存在<code>GOPATH env</code>中，这是我们的工作目录。通过我们的工作目录中的pkg文件夹进入包<code>cd $GOPATH/pkg</code>。</p><h4 id=创建自定义包>创建自定义包<a hidden class=anchor aria-hidden=true href=#创建自定义包>#</a></h4><p>  让我们从创建一个文件夹custom_package开始：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; mkdir custom_package 
</span></span><span style=display:flex><span>&gt; <span style=color:#8be9fd;font-style:italic>cd</span> custom_package
</span></span></code></pre></div><p>  要创建自定义包，我们需要先使用我们需要的包名创建一个文件夹。假设我们正在构建一个包<code>person</code>。我们在<code>custom_package</code>目录中创建一个名为<code>person</code>的目录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; mkdir person
</span></span><span style=display:flex><span>&gt; <span style=color:#8be9fd;font-style:italic>cd</span> person
</span></span></code></pre></div><p>  现在让我们在这个文件夹中创建一个文件person.go。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> person
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>Description</span>(name <span style=color:#8be9fd>string</span>) <span style=color:#8be9fd>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;The person name is: &#34;</span> <span style=color:#ff79c6>+</span> name
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>secretName</span>(name <span style=color:#8be9fd>string</span>) <span style=color:#8be9fd>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;Do not share&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>  我们现在需要安装包，以便可以导入和使用它。所以让我们安装它：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; go install
</span></span></code></pre></div><p>  现在让我们回到custom_package文件夹并创建一个<code>main.go</code>文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span>(
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;custom_package/person&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>(){ 
</span></span><span style=display:flex><span>  p <span style=color:#ff79c6>:=</span> person.<span style=color:#50fa7b>Description</span>(<span style=color:#f1fa8c>&#34;Milap&#34;</span>)
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(p)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// =&gt; The person name is: Milap
</span></span></span></code></pre></div><p>  现在我们可以导入<code>person</code>我们创建的包并使用函数<code>Description</code>。请注意，<code>secretName</code>我们在包中创建的功能将无法访问。在Go中，以<code>大写字母</code>开头的方法名称将是私有的<code>private</code>。</p><h4 id=包文档><strong>包文档</strong><a hidden class=anchor aria-hidden=true href=#包文档>#</a></h4><p>  Go内置了对包文档的支持。运行以下命令以生成文档：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>godoc person Description
</span></span></code></pre></div><p>  这将为我们的包人员生成Description函数的文档。要查看文档，请使用以下命令运行Web服务器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>godoc -http<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;:8080&#34;</span>
</span></span></code></pre></div><p>  现在转到<code>http://localhost:8080/pkg</code>查看我们刚创建的包的文档。</p><h4 id=go的内置包>Go的内置包<a hidden class=anchor aria-hidden=true href=#go的内置包>#</a></h4><h5 id=fmt><strong>fmt</strong><a hidden class=anchor aria-hidden=true href=#fmt>#</a></h5><p>  该包实现了格式化的I/O功能，我们已经使用该包打印出stdout。</p><h5 id=json><strong>json</strong><a hidden class=anchor aria-hidden=true href=#json>#</a></h5><p>  Go中另一个有用的包是json包。用于编码/解码JSON。让我们举个例子来编码/解码json：</p><p>  编码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;encoding/json&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>(){
</span></span><span style=display:flex><span>  mapA <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#8be9fd>int</span>{<span style=color:#f1fa8c>&#34;apple&#34;</span>: <span style=color:#bd93f9>5</span>, <span style=color:#f1fa8c>&#34;lettuce&#34;</span>: <span style=color:#bd93f9>7</span>}
</span></span><span style=display:flex><span>  mapB, _ <span style=color:#ff79c6>:=</span> json.<span style=color:#50fa7b>Marshal</span>(mapA)
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#8be9fd;font-style:italic>string</span>(mapB))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>  解码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;encoding/json&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> response <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>  PageNumber <span style=color:#8be9fd>int</span> <span style=color:#f1fa8c>`json:&#34;page&#34;`</span>
</span></span><span style=display:flex><span>  Fruits []<span style=color:#8be9fd>string</span> <span style=color:#f1fa8c>`json:&#34;fruits&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>(){
</span></span><span style=display:flex><span>  str <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>`{&#34;page&#34;: 1, &#34;fruits&#34;: [&#34;apple&#34;, &#34;peach&#34;]}`</span>
</span></span><span style=display:flex><span>  res <span style=color:#ff79c6>:=</span> response{}
</span></span><span style=display:flex><span>  json.<span style=color:#50fa7b>Unmarshal</span>([]<span style=color:#8be9fd;font-style:italic>byte</span>(str), <span style=color:#ff79c6>&amp;</span>res)
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(res.PageNumber)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// 1
</span></span></span></code></pre></div><p>  在使用<code>Unmarshal</code>解码json字符串时，第一个参数是json字符串，第二个参数是我们希望json映射到的响应类型<code>struct</code>的地址。请注意，<code>json:"page"</code>映射页面键是结构中的<code>PageNumber</code>键。</p><h3 id=错误处理>错误处理<a hidden class=anchor aria-hidden=true href=#错误处理>#</a></h3><h4 id=error>Error<a hidden class=anchor aria-hidden=true href=#error>#</a></h4><p>  错误<code>Error</code>是程序不被希望出现的意外的结果。假设我们正在对外部服务进行API调用，此API调用可能成功也可能失败。当存在错误类型时，我们就可以识别Go程序中的错误。看看下面这个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>resp, err <span style=color:#ff79c6>:=</span> http.<span style=color:#50fa7b>Get</span>(<span style=color:#f1fa8c>&#34;http://example.com/&#34;</span>)
</span></span></code></pre></div><p>  这里对错误对象的API调用可能会成功或失败。我们可以检查错误是否为<code>nil</code>，并处理响应：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>(){
</span></span><span style=display:flex><span>  resp, err <span style=color:#ff79c6>:=</span> http.<span style=color:#50fa7b>Get</span>(<span style=color:#f1fa8c>&#34;http://example.com/&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Println</span>(err)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(resp)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=自定义错误>自定义错误<a hidden class=anchor aria-hidden=true href=#自定义错误>#</a></h5><p>  当我们编写自己的函数时，有些情况下我们会遇到错误。可以在错误对象的帮助下返回这些错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>Increment</span>(n <span style=color:#8be9fd>int</span>) (<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> n &lt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// return error object
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, errors.<span style=color:#50fa7b>New</span>(<span style=color:#f1fa8c>&#34;math: cannot process negative number&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> (n <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>), <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>  num <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>5</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> inc, err <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>Increment</span>(num); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;Failed Number: %v, error message: %v&#34;</span>, num, err)
</span></span><span style=display:flex><span>  }<span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;Incremented Number: %v&#34;</span>, inc)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>  在Go中构建的大多数包或我们使用的外部包都有错误处理机制。所以我们调用的任何函数都可能存在错误。这些错误永远不应该被忽略，并且总是在我们称之为函数的地方优雅地处理，就像我们在上面的例子中所做的那样。</p><h4 id=panic>Panic<a hidden class=anchor aria-hidden=true href=#panic>#</a></h4><p><code>panic</code>是一种未经处理的事件，在程序执行期间突然遇到。在Go中，<code>panic</code>不是处理程序中异常的理想方式。建议使用错误对象。发生<code>panic</code>时程序会停止执行。<code>panic</code>之后执行的事件就是<code>defer</code>。</p><h4 id=defer>Defer<a hidden class=anchor aria-hidden=true href=#defer>#</a></h4><p>  <code>defer</code>总是在函数结束时执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>f</span>()
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Returned normally from f.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>f</span>() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>defer</span> <span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> r <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>recover</span>(); r <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>            fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Recovered in f&#34;</span>, r)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Calling g.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>g</span>(<span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Returned normally from g.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>g</span>(i <span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> i &gt; <span style=color:#bd93f9>3</span> {
</span></span><span style=display:flex><span>        fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Panicking!&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>panic</span>(fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;%v&#34;</span>, i))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>defer</span> fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Defer in g&#34;</span>, i)
</span></span><span style=display:flex><span>    fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Printing in g&#34;</span>, i)
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>g</span>(i <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>  在上面的例子中，我们使用<code>panic()</code>来故意终止程序的执行。正如你所注意到的，有一个<code>defer</code>语句，它将使程序在程序执行结束时执行该行。当我们需要在函数结束时执行某些操作时，也可以使用<code>defer</code>，例如关闭文件。</p><h3 id=并发>并发<a hidden class=anchor aria-hidden=true href=#并发>#</a></h3><p>  Go是建立在并发性的基础上的。Go中的并发可以通过轻量级线程的Go例程来实现。</p><h4 id=协程go-routine>协程(go routine)<a hidden class=anchor aria-hidden=true href=#协程go-routine>#</a></h4><p>  go协程<code>routine</code>是可以与另一个函数并行或同时运行的函数。创建go协程非常简单。只需在函数前面添加关键字<code>go</code>，我们就可以使它并行执行。go协程非常轻量级，因此我们可以创建数千个协程。让我们看一个简单的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>go</span> <span style=color:#50fa7b>c</span>()
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;I am main&#34;</span>)
</span></span><span style=display:flex><span>  time.<span style=color:#50fa7b>Sleep</span>(time.Second <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>c</span>() {
</span></span><span style=display:flex><span>  time.<span style=color:#50fa7b>Sleep</span>(time.Second <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;I am concurrent&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// I am main
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// I am concurrent
</span></span></span></code></pre></div><p>  正如上面的示例，函数<code>c()</code>是一个Go协程，它与主Go线程并行执行。有时我们希望在多个线程之间共享资源。Go更倾向于一个线程的变量不与另一个线程共享，因为这会增加死锁和资源等待的可能性。还有另一种在Go协程之间共享资源的方法：管道<code>Channels</code>。</p><h4 id=管道channel>管道（channel）<a hidden class=anchor aria-hidden=true href=#管道channel>#</a></h4><p>  我们可以使用通道在两个Go协程之间传递数据。在创建<code>channel</code>时，必须指定<code>channel</code>接收的数据类型。让我们创建一个字符串类型的简单<code>channel</code>，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>c <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>string</span>)
</span></span></code></pre></div><p>  使用此<code>channel</code>，我们可以发送字符串类型数据。可以在此频道中<code>发送</code>和<code>接收</code>数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>(){
</span></span><span style=display:flex><span>  c <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>string</span>)
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>go</span> <span style=color:#8be9fd;font-style:italic>func</span>(){ c <span style=color:#ff79c6>&lt;-</span> <span style=color:#f1fa8c>&#34;hello&#34;</span> }()
</span></span><span style=display:flex><span>  msg <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&lt;-</span>c
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(msg)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>//&#34;hello&#34;
</span></span></span></code></pre></div><p>  接收方等待发送方向<code>channel</code>发送数据。</p><h4 id=单向通道>单向通道<a hidden class=anchor aria-hidden=true href=#单向通道>#</a></h4><p>  在某些情况下，我们希望Go协程通过<code>channel</code>接收数据但不发送数据，反之亦然。为此，我们还可以创建<strong>单向通道</strong>。让我们看一个简单的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> (
</span></span><span style=display:flex><span> <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span> ch <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>string</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> <span style=color:#ff79c6>go</span> <span style=color:#50fa7b>sc</span>(ch)
</span></span><span style=display:flex><span> fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#ff79c6>&lt;-</span>ch)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>sc</span>(ch <span style=color:#8be9fd;font-style:italic>chan</span><span style=color:#ff79c6>&lt;-</span> <span style=color:#8be9fd>string</span>) {
</span></span><span style=display:flex><span> ch <span style=color:#ff79c6>&lt;-</span> <span style=color:#f1fa8c>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>  在上面的例子中，sc是一个Go协程，它只能向通道发送消息但不能接收消息。</p><h4 id=使用select为go例程组织多个通道>使用select为Go例程组织多个通道<a hidden class=anchor aria-hidden=true href=#使用select为go例程组织多个通道>#</a></h4><p>  函数可能有多个通道正在等待执行。为此，我们可以使用select语句。让我们看一个更清晰的例子：：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> (
</span></span><span style=display:flex><span> <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f1fa8c>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span> c1 <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>string</span>)
</span></span><span style=display:flex><span> c2 <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>string</span>)
</span></span><span style=display:flex><span> <span style=color:#ff79c6>go</span> <span style=color:#50fa7b>speed1</span>(c1)
</span></span><span style=display:flex><span> <span style=color:#ff79c6>go</span> <span style=color:#50fa7b>speed2</span>(c2)
</span></span><span style=display:flex><span> fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;The first to arrive is:&#34;</span>)
</span></span><span style=display:flex><span> <span style=color:#ff79c6>select</span> {
</span></span><span style=display:flex><span> <span style=color:#ff79c6>case</span> s1 <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&lt;-</span>c1:
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(s1)
</span></span><span style=display:flex><span> <span style=color:#ff79c6>case</span> s2 <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&lt;-</span>c2:
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(s2)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>speed1</span>(ch <span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>string</span>) {
</span></span><span style=display:flex><span> time.<span style=color:#50fa7b>Sleep</span>(<span style=color:#bd93f9>2</span> <span style=color:#ff79c6>*</span> time.Second)
</span></span><span style=display:flex><span> ch <span style=color:#ff79c6>&lt;-</span> <span style=color:#f1fa8c>&#34;speed 1&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>speed2</span>(ch <span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>string</span>) {
</span></span><span style=display:flex><span> time.<span style=color:#50fa7b>Sleep</span>(<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>*</span> time.Second)
</span></span><span style=display:flex><span> ch <span style=color:#ff79c6>&lt;-</span> <span style=color:#f1fa8c>&#34;speed 2&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>  在上面的示例中，<code>main</code>正在等待两个管道<code>c1</code>和<code>c2</code>。使用<code>select case</code>语句打印主函数，消息从管道发送，无论它先收到哪个。</p><h4 id=缓冲通道>缓冲通道<a hidden class=anchor aria-hidden=true href=#缓冲通道>#</a></h4><p>  有些情况下我们需要向管道发送多个数据。可以为此创建缓冲通道<code>buffered channel</code>。使用缓冲通道，接收器在缓冲区已满之前不会收到消息。我们来看看这个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>(){
</span></span><span style=display:flex><span>  ch <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd>string</span>, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>  ch <span style=color:#ff79c6>&lt;-</span> <span style=color:#f1fa8c>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>  ch <span style=color:#ff79c6>&lt;-</span> <span style=color:#f1fa8c>&#34;world&#34;</span>
</span></span><span style=display:flex><span>  fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#ff79c6>&lt;-</span>ch)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=结尾>结尾<a hidden class=anchor aria-hidden=true href=#结尾>#</a></h3><p><strong>为什么Golang会成功?</strong></p><blockquote><p><em>简单… — Rob-pike</em></p></blockquote><p>目前为止我们已经了解了Go的一些主要组件和功能：</p><ol><li>变量，数据类型</li><li>Array、Slices和Map</li><li>函数</li><li>循环和条件语句</li><li>指针</li><li>包</li><li>结构、方法和接口</li><li>错误处理</li><li>并发 - Go routine和channel</li></ol><p><em>恭喜你，你现在对Go有了不错的认识。</em></p><blockquote><p><em> </em> <em>抛弃了1000行代码的那天是我最富有成效的日子之一。</em></p><p><em> </em> <em> </em> <em> </em> <em> </em> <em> </em> <em> </em> <em> </em> <em> </em> <em> </em> <em>— Ken Thompson</em></p></blockquote><p>不要止步于此，继续前进。在大脑中思考一个小规模的应用程序并开始构建。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://lvlv.fun/tags/go/>Go</a></li></ul><nav class=paginav><a class=prev href=https://lvlv.fun/posts/2019-03-14/><span class=title>« Prev</span><br><span>Protobuf 总结</span></a>
<a class=next href=https://lvlv.fun/posts/2018-12-22/><span class=title>Next »</span><br><span>Learning go from zero to hero - Part 1</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var t=document,e=t.createElement('script');e.async=!0,e.src='//lvs-playground.disqus.com/embed.js',e.setAttribute('data-timestamp',+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://lvlv.fun>Lv's Playground</a></span>
<span>|</span>
<span><a href=https://beian.miit.gov.cn/>皖ICP备2022006072号-1</a></span>
<span>|</span>
<span><img style=display:inline;margin-bottom:-.8em src="https://matomo.lvlv.fun/index.php?module=FlagCounter&action=image&idSite=1&period=range&date=last365&sort=popular&activated=&rows=1&cols=1&showcode=1&showflag=0&fontsize=8&fontcolor=218,218,219&font=Roboto-Regular" alt=flag></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll('pre > code').forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement('button');e.classList.add('copy-code'),e.innerText='copy';function s(){e.innerText='copied!',setTimeout(()=>{e.innerText='copy'},2e3)}e.addEventListener('click',o=>{if('clipboard'in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand('copy'),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>